[{"title":"C--Test01","url":"/2018/09/26/C语言练习1/","content":"\n\n\n##  交换两变量的值\n\n>  题目：给定两个整形变量的值，将两个值的内容进行交换。\n\n这可以使用指针变量进行交换。切不可直接接交换\n\n<!--more-->\n\n```C\n有两种思想，看看哪组正确？\n//参数为指针变量\nvoid swap(int* x, int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n//参数为普通变量\nvoid swap(int x, int y){\n\tint temp = 0;\n\ttemp = x;\n\tx = y;\n\ty = temp;\n}\n```\n\n图解：\n\n用指针的话，显然在内存二者已经交换了！\n\n{% asset_img 指针.png  用指针 %}\n\n但是，当不用指针的话，两组变量都有自己独立的内存空间，没有产生关联，当然num1和num2没有在内存中发生交换。\n\n{% asset_img 非指针.png  不用指针 %}\n\n那么，这时候只要给swap函数传两个参数即可进行交换。\n\n代码为：\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n//给定两个整形变量的值，将两个值的内容进行交换。\nvoid swap(int* x, int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\nint main(){\n\tint num1 = 2;\n\tint num2 = 8;\n\tprintf(\"num1=%d num2=%d\\n\",num1,num2);\n\tswap(&num1, &num2);\n\tprintf(\"num1=%d num2=%d\\n\",num1,num2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n> 题目：不允许创建临时变量，交换两个数的内容\n\n首先，可以使用两变量之和或者差、积等促成一个临时变量。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//不允许创建临时变量，交换两个数的内容\nint main()\n{\n\tint a = 0;\n\tint b = 0;\n\tprintf(\"请输入两个数：\");\n\tscanf(\"%d,%d\", &a,&b);\n\tprintf(\"交换前：\\n\");\n\tprintf(\"a = %d\\nb = %d\\n\",a,b);\n\ta = a + b;  \n\tb = a - b; //原来的a\n\ta = a - b;//a减去原来的a就是原来的b\n \tprintf(\"交换后: \\n\");\n\tprintf(\"a = %d\\nb = %d\\n\", a, b);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n> 上述方法有一个明显的缺陷，就是当a和b足够大时a+b可能int类型存不下发生溢出现象\n\n解决办法：按位异或（^）\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//不允许创建临时变量，交换两个数的内容(按位异或)\nint main()\n{\n\tint a = 0;\n\tint b = 0;\n\tprintf(\"请输入两个数：\");\n\tscanf(\"%d,%d\", &a,&b);\n\tprintf(\"交换前：\\n\");\n\tprintf(\"a = %d\\nb = %d\\n\",a,b);\n\t//\ta 010  //b\n\t//\tb 101 //\n\t//    111 //a\n\ta = a^b;\n\tb = a^b;//原来的a\n\ta = a^b;//a异或原来的a就是原来的b\n \tprintf(\"交换后: \\n\");\n\tprintf(\"a = %d\\nb = %d\\n\", a, b);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n>  这个方法就不会发生溢出现象。但是实际并不提倡，因为效率较低！ok\n\n> 题目： 将数组A中的内容和数组B中的内容进行交换。（数组一样大）\n\n一样的思路，用一个交换函数swap进行操作！\n\n> 注意点：这里传的是数组每一项的地址，如&a[5]；\n>\n> 还有，尽可能的把功能单独出来作为函数。用来调用！\n>\n> C语言中数组的长度计算为：sizeof(x)/sizeof(x[0])  其中sizeof计算的是多少个字节，然后除以第一项所占的字节就是数组的长度。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n#define arr_length(x) sizeof(x)/sizeof(x[0])\n//将数组A中的内容和数组B中的内容进行交换。（数组一样大） \n\n//交换函数\nvoid swap(int* x,int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n//打印数组\nvoid PrintArrays(int arr[],int length){\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (i == 0){\n\t\t\tprintf(\"[%d,\",arr[0]);\n\t\t}\n\t\tif (i < length - 1){\n\t\t\tprintf(\"%d,\", arr[i]);\n\t\t}else{\n\t\t\tprintf(\"%d]\", arr[i]);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n//给数组输入值\nvoid ScanfArrays(int arr[], int length){\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tscanf(\"%d\", &arr[i]);\n\t}\n}\nint main(){\n\tint A[5];\n\tint B[5];\n\n\tprintf(\"请输入5个数存于A数组中:\");\n\tScanfArrays(A, arr_length(A));\n\tprintf(\"请输入5个数存于B数组中:\");\n\tScanfArrays(B, arr_length(B));\n\n\tprintf(\"交换前的A数组:\");\n\tPrintArrays(A, arr_length(A));\n\tprintf(\"交换前的B数组:\");\n\tPrintArrays(B, arr_length(B));\n\n\t//交换A和B数组\n\tfor (int index = 0; index < 5; index++)\n\t{\n\t\tswap(&A[index],&B[index]);\n\t}\n\n\tprintf(\"交换后的A数组:\");\n\tPrintArrays(A, arr_length(A));\n\tprintf(\"交换后的B数组:\");\n\tPrintArrays(B, arr_length(B));\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n## 求10个整数中最大值\n\n>  题目：求10个整数中最大值\n\n思路：将这10个数存到一个数组里面，从这数组中找到最大的值就ok了。假设数组中第一个元素为最大值max，遍历整个数组跟这个最大值max进行比较，若有更大的值那么就把大的值赋给max。\n\n\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//3.求10 个整数中最大值。\nint main(){\n\tint arr[10];\n\tint i = 0;\n\tprintf(\"请输入10个数,用\\\",\\\"隔开:\");\n\tfor ( i = 0; i < 10; i++)\n\t{\n\t\tscanf(\"%d,\",&arr[i]);\n\t}\n\tint max = arr[0];\n\tfor (i = 1; i < 10; i++)\n\t{\n\t\tif (arr[i]>max)\n\t\t\tmax = arr[i];\n\t}\n\tprintf(\"max=%d\\n\", max);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n## 求两个数的最大公约数\n\n> 题目：求两个数的最大公约数\n\n最大公约数有很多种求法：例如辗转相除法、辗转相减法等等。这次我用的是辗转相除法。方法就是用较大数模较小数得到的余数，然后用较小数模这个余数，以此类推直到余数等于零，那么这时候的较小数就是两数的最大公约数。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n//求两个数的最大公约数\n\nint main(){\n\tint num1, num2;\n\tint temp;\n\tprintf(\"请输入两个数：\");\n\tloop:scanf(\"%d,%d\", &num1, &num2);\n\tif (num2 == 0){\n\t\tprintf(\"你的输入有误,请重新输入\\n\");\n\t\tgoto loop;\n\t}\n\twhile (num1%num2 != 0){ //辗转相除法\n\t\ttemp = num1%num2;\n\t\tnum1 = num2;\n\t\tnum2 = temp;\n\t}\n\tprintf(\"最大公约数为：%d\\n\", num2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n>  相同的，最小公倍数乘以最大公约数等于两数之积。\n\n##  1到 100 的所有整数中出现多少次数字9\n\n>  题目：编写程序数一下 1到 100 的所有整数中出现多少次数字9。\n\n分析：这类题目一定要分步骤来看。个位和十位分别来看，再具体确定判断条件。个位上的9就是9、19 、29、39.....99。模10都等于9；十位上的是90、91、92....99.。注意这把99数了两遍，但是个位数了10位就不会再数了。ok~\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n//编写程序数一下 1到 100 的所有整数中出现多少次数字9。\n//9,19,29,39....   90 92 93...\n\nint main(){\n\tint count = 0;\n\tfor (int i = 1; i < 100; i++){\n\t\tif (i%10 == 9){ //个位有9的数，包括了99\n\t\t\tcount += 1;\n\t\t}\n\t\tif (i/10 == 9){//十位数有9的数，90~98，99在上面已经数过了。\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tprintf(\"出现9的次数为%d次\\n\", count);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n","tags":["C语言"],"categories":["lang"]},{"title":"素数计算","url":"/2018/09/21/C_计算素数/","content":"\n\n\n## 1.打印100~200之间的素数\n\n>  素数：当一个数的因子只有1和它本身的时候就是素数。特殊也是最小的质数是2。\n\n<!---more-->\n\n> 分析 ：一般的，拿一个数n(n!=2)除以2，除以3，直达除到n-1，若可以整除，说明n为质数,反之非质数\n>\n> 当然，也不是一点得除到n-1，其实到n/2都可以了。\n>\n> 甚至，其实到根号n都可以了。\n>\n> 还有，除了2偶数都不可能是质数，那直接把偶数排除掉 for(i = 3;i<n/2;i+=2)\n\n```C\n#include<stdio.h>\n\n//求100-200之间的素数；\nint main()\n{\n\tint count = 0;\n\tfor (int i = 100; i <= 200; i++)\n\t{\n\t\tif (IsPrime(i)){\n\t\t\tcount++;\n\t\t\tprintf(\" %d \", i);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"%d\", count);\n\treturn 0;\n}\nint IsPrime(int n)  //判断一个数是否为素数\n{\n\tif (n <= 1){\n\t\treturn 0;\n\t}\n\tif (n == 2){\n\t\treturn 1;\n\t}\n\tfor (int i = 2; i < n; i++){\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n```\n\n>  [作为参考](https://blog.csdn.net/PriestessofBirth/article/details/79435124),等到后面研究算法的时候可能有更加优化的方案！\n\n\n\n## 2.输出乘法口诀表\n\n>  用一对嵌套for循环可以轻易实现，注意格式化打印\n\n```C\n#include <stdio.h>\n//打印乘法口诀表\nint main()\n{\n\tfor (int i = 1; i < 10; i++){\n\t\tfor (int j = 1 ; j<= i ; j++)\n\t\t{\n\t\t\tprintf(\"%d*%d=%d\\t\",j,i,i*j);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n结果：{% asset_img 乘法口诀表.png  乘法口诀表%}\n\n##  3.判断1000~2000年之间的闰年\n\n>  闰年判断条件：四年一闰，一百年不闰。四百年又一闰。\n\n```c\n#include <stdio.h>\n//判断1000年---2000年之间的闰年\nint main(){\n\tint count = 0;\n\tfor (int i = 1000; i <= 2000; i++)\n\t{\n\t\tif (IsLeapYear(i)){\n\t\t\tprintf(\"%d \", i);\n\t\t\tcount++;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"闰年有%d个\\n\",count);\n\treturn 0;\n}\nint IsLeapYear(int year){\n\tif ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n\n{% asset_img 判断闰年.png  判断闰年 %}","tags":["C语言"],"categories":["lang"]},{"title":"先定一个小目标~","url":"/2018/09/21/先定一个小目标~/","content":"\n先做一个自我介绍，我叫史腾飞，好就这样！\n大三了，大学时间已经过半了，不是感叹时间过得太快了，但是我也不能掉队呀！\n\n- 学习编程，代码量尤为重要。所以我可以保证我每天三个小时以上的coding时间。\n- 学习，就要做好笔记，以便于回顾。这也是写博客的主要目的。\n- 杜绝眼高手低。\n- 我会定期制定我的学习计划。\n\n> 做你不想做的事，你会发现也不过如此！\n>\n> 加油！","tags":["Flags"],"categories":["others"]},{"title":"Hexo+GitHub打造个人博客","url":"/2018/09/17/hexo搭建博客/","content":"## 1.准备工作\n1.安装nodejs\n去官网下载nodejs安装(推荐安装4.x),安装之后在命令行 node -v,如果成功说明node环境ok,不成功就去环境变量配置一下.\n2.安装hexo\n使用命令 npm install hexo -g,执行hexo -v 查看版本,本教程适合3.1.1以上版本\n3.安装git\n<!-- more -->\n去官网下载git安装\n4.配置git\n配置ssh私钥,上传到github上\n## 2.github-pages的说明\n- github有两种主页,一种是github-page(个人主页),一种是项目主页,本教程针对个人主页\n- github-page需要将hexo博客发布到repository的master(主干)即可\n- github的个人主页要求repository的名称和username一致，加入username是tom，则repository的名称为tom.github.io\n## 3.使用hexo写博客\n```\n- 新建一个文件夹myblog,\n- 右键git bash here使用git的shell\n- 在shell中输入hexo init,回车执行\n- 在shell中输入hexo g ,回车\n- 在shell中hexo s,回车\n- 去浏览器访问http://localhost:4000,访问到主页,然后在shell中ctrl c停止\n- 在shell中hexo new \"first-blog\",回车\n- 在shell中hexo g ,回车\n- 在shell中hexo s ,回车,在访问\n- ok,在本地测试就没问题了\n```\n## 4.发布到github\n打开项目根部录下的.config.yml,找到deploy,修改如下:\n```\ndeploy:\n - type: git\n   repo: git@github.com:yourname/yourname.github.io.git\n     branch: branch\n  message: message\n```\n## 5.常用命令\n\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\nhexo clean  删除public文件夹\n\n```\n## 6.常见问题\n```\n发布不上去：\nnpm install hexo-deployer-git --save 安装依赖包\n```\n## 7.具体设置\nhexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的；\n- 修改主题\n\n修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。\n如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。\n\n全局的_config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。\n需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。\n\n本文参考了博客：[参考博客](https://geeksblog.cc/hexo-githup-blog.html)","tags":["hexo"],"categories":["others"]},{"title":"线程和并发--基础操作","url":"/2018/09/17/线程和并发--基础操作/","content":"## 概述\n**并发和并行**是即相似又有区别：\n- 并行：指两个或多个事件在同一时刻发生；\n- 并发：指两个或多个事件在同一时间段内发生。\n<!--more-->\n**进程**是指一个内存中运行中的应用程序。每个进程都有自己独立的一块内存空间，一个应用程序可以同时启动多个进程。比如在Windows系统中，一个运行的abc.exe就是一个进程。\n那么我们此时就可以处理同时玩游戏和听音乐的问题了，我们可以设计成两个程序，一个专门负责玩游戏，一个专门负责听音乐。\n但是问题来了，要是要设计一个植物大战僵尸游戏，我得开N个进程才能完成多个功能，这样的设计显然是不合理的。\n更何况大多数操作系统都不需要一个进程访问其他进程的内存空间，也就是说进程之间的通信很不方便。\n此时我们得引入“线程”这门技术，来解决这个问题。\n\n**线程**是指进程中的一个执行任务(控制单元)，一个进程可以同时并发运行多个线程，如：多线程下载软件。\n一个进程至少有一个线程，为了提高效率，可以在一个进程中开启多个执行任务,即多线程。\n多进程：操作系统中同时运行的多个程序。\n多线程：在同一个进程中同时运行的多个任务。\n我们查看Windows环境下的任务管理器：\n  在操作系统中允许多个任务，每一个任务就是一个进程，每一个进程也可以同时执行多个任务，每一个任务就是线程。\n\n**多线程**作为一种多任务、并发的工作方式，当然有其存在优势：\n\n- 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。\n- 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.\n- Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程.\n\n## 用java语言创建进程\n\n```\nimport java.io.IOException;\n//如何用java语言开启一个进程\npublic class ProcessDemo {\n\tpublic static void main(String[] args) throws IOException{\n\t\t//方式一：使用Runtime的exec方法\n\t\tRuntime.getRuntime().exec(\"notepad\");\n\t\t//方式二：使用ProcessBuilder类中的start方法\n\t\tProcessBuilder pb = new ProcessBuilder(\"notepad\");\n\t\tpb.start();\n\t}\n}\n\n```\n## 创建和启动线程\n\n### 方式一：继承Thread类\n\n1. 自定义类继承于Thread类，那么该自定义类就是线程类；\n\n2．覆写run方法，将线程运行的代码存放在run中；\n\n3．创建自定义类的对象，即线程对象；\n\n4．调用线程对象的start方法，启动线程。\n\n```\npackage thread_create;\n//继承方式 创建和启动线程\nclass MusicThread extends Thread{      //MusicThread是线程子类\n\tpublic void run() {               //子类必须重写run()方法\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"听音乐\"+i);\n\t\t}\n\t}\n\t\n}\npublic class ExtendsThreadDemo {\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"玩游戏\"+i);\n\t\t\tif( i == 10){\n\t\t\t\tMusicThread t = new MusicThread();  //创建线程子类的实例\n\t\t\t\tt.start(); //底层也调用了run();  启动线程\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}\n\n```\n\n### 方式二：实现Runnable接口\n\n1．自定义类实现Runnable接口；\n\n2．覆写run方法，线程运行的代码存放在run中；\n\n3．通过Thread类创建线程对象，并将实现了Runnable接口的实现类对象作为参数传递给Thread类的构造器。\n\n4．Thread类对象调用start方法，启动线程。\n```\nclass MusicRunnable implements java.lang.Runnable{         //注意MusicRunnable类不是线程类或者线程子类\n\tpublic void run() {\t\t\t\t\t\t\t\t\t   //接口的实现必须覆盖方法。\t\t\t\t\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"听音乐\"+i);\n\t\t}\n\t}\n}\npublic class ImplementsRunnableDemo {\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"玩游戏\"+i);\n\t\t\tif( i == 10){\n\t\t\t\tRunnable t = new MusicRunnable();        //启动线程必须用线程类对象调用start();\n\t\t\t\tnew Thread(t).start();             //类Thread的一个构造器中Thread(Runnable target)分配新的 Thread 对象。\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 对比两种方法（吃苹果比赛）\n**1、继承Thread类** \n\n```\n/**\n * \t案例:存在50个苹果,现在有请三个童鞋(小A,小B,小C)上台表演吃苹果.\n * \t\t因为A,B,C三个人可以同时吃苹果,此时得使用多线程技术来实现这个案例.\n *\n *       此处程序不合理,ABC每个线程都执行50次,即ABC每个人都吃一次编号50的苹果\n */\nclass Person extends Thread{\n\tprivate  int num= 50;\n\tPerson(String name){\n\t\tsuper(name);\n\t}\n\tpublic void run() {\n\t\tfor(int i = 0;i < 50;i++){\n\t\tif(num > 0)\t\n\t\tSystem.out.println(super.getName()+\"吃了第\"+num--+\"个苹果\");\n\t\t}\n\t}\t\n}\n//使用继承Thread的方式创建线程\npublic class ExtendsDemo {\n\tpublic static void main(String[] args){\n\t\tPerson p1 = new Person(\"A\");\n\t\tp1.start();\n\t\tPerson p2 = new Person(\"B\");\n\t\tp2.start();\n\t\tPerson p3 = new Person(\"C\");\n\t\tp3.start();\n\t}\n}\n\n```\n\n**2、实现Runnable接口** \n\n```\nclass Apple implements Runnable{\n\tprivate int num = 50;\n\tpublic void run(){\n\t\tfor(int i = 0; i< 50 ;i++){\n\t\t\tif(num > 0){\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\"吃了第\"+num--+\"个苹果\");\n\t\t\t}//Thread.currentThread()   返回对当前正在执行的线程对象的引用。\n\t\t}\n\t}\n}\n//使用实现Runnable接口的方式，这种方法可以解决此问题\npublic class ImplementsDemo {\n\tpublic static void main(String[] args){\n\t\tRunnable r = new Apple();\n\t\tnew Thread(r,\"A\").start();\n\t\tnew Thread(r,\"B\").start();\n\t\tnew Thread(r,\"C\").start();\n\t}\n}\n\n```\n\n**对比**\n\n继承方式：\n- java中类是单继承的，如果继承了Thread，该类就不能再有其他的直接父类\n- 从操作上分析，继承方式更简单，获取线程的名字也简单（操作上，简单）\n- 从多线程共享一个资源上分析，**继承方式不能做到**\n\n实现方式\n- java中类可以实现接口，此时该类还可以继承其他类，并且可以实现接口（设计上，更优雅）\n- 从操作上分析，实现方式稍微复杂点，获取线程的名字比较复杂，得使用currentThread()获取当前线程的引用。\n- 从多线程共享一个资源上分析，**实现方式可以做到**。\n\n\n\n"}]