[{"url":"/2018/10/16/ArrayList模拟球员上场案列/","content":"假设我现在是球队的教练,我需要安排上场的球员(安排5个).模拟数据存储的案例,模拟上场球员的球衣号码的存储:        \n\nInteger[] players = null;\n\n作为一个教练,要安排上场:          \n\n<!--more-->\n\n- 1):初始容量为5的线性列表,准备用来存储场上的5个球衣号码.           \n- 2):安排5个球员上场:[11,22,33,44,55].           \n- 3):查询指定位置的球员的球衣号码是多少.查询索引位置为2的球衣号码是:33.           \n- 4):根据球衣号码查询该球员在场上的索引位置. 44球衣号的球员在场上的索引位置是:3.           \n- 5):替换场上索引位置为2的球员,替换之后该位置的球衣编号为333. 333把33替换了.           \n- 6):替换球衣号码为22的球员,替换之后为222.           \n- 7):把场上索引位置为2的球衣罚下场(注意:罚下,没有补位.).           \n- 8):按照球员在场上的位置,打印出球衣号码,打印风格:[11,22,33,44,55].\n\n\n\n代码已经分析：\n\nhttps://github.com/EarthSoar/JavaExamples/tree/master/src/Aarray"},{"title":"浅谈排序算法","url":"/2018/10/08/浅谈排序/","content":"\n排序算法有很多种，今天先谈谈一些简单的排序算法。包括桶排序、冒泡排序和快速排序算法。后期总结各种排序算法。\n\n<!--more-->\n\n### 桶排序（BucketSort）\n\n排序过程：\n\n>  假如我们现在要排序的一组数为：5,3,5,2,8. 这组数都在0-10的范围之内。这个时候，我们可以拿11个桶，标号为0,1,2,3......10。也就是定义长度为11的数组。现在我们来遍历这些数字，第一个数字为5，那么给第五号桶中插一个小红旗，第二个数字为3，给第三号桶插一个小红旗，以此类推。其中，插入一个小红旗代表的是数组元素+1（开始初始化数组元素都为0)，遍历完成之后，可以查看所有桶中小红旗的数量，也就是数组中存储元素的个数。发现a[5] = 2，表示5这个数字出现了两次。从0号桶开始，a[0] = 0,表示没有0这个数字，依次遍历到 10就结束了，也就把这些数字从小到大排好了。\n\n{% asset_img 桶排序.png  桶排序%}\n\n当然，如果需要对0-100之间的数进行排序，就需要101个桶，桶的作用就是一个标志。\n\n把标志数组起个名字为book。\n\n写代码思路：\n\n>1.把book数组初始化，也就是把里面都写成0\n>\n>2.把需要排序的一组数放在一个数组里面。\n>\n>3.循环放入的过程中，对book[i]++。\n>\n>4.依次判断编号为0~10之间的桶中小红旗的个数，即book[i]的值\n>\n>5.有n个小红旗（book[i] = n）就打印n次这个数。\n\n代码如下：\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n//桶排序：对于0~100之间的数排序的时候，这时候需要有101个桶（数组长度为101的数组），插个小旗（加一）用来标记每个数出现的次数。\n//然后，看这些桶中（遍历这个数组）小旗的数目（多少个1），有多少只旗（多少个1）就（打印多少次这个数）表示这个桶的标号（数）出现了几次；\nint main(){\n\tint book[11];//先拿11个桶，0~10之间的数进行排序。\n\tint t = 0;\n\tfor (int i = 0; i < 11; i++)\n\t{\n\t\tbook[i] = 0; //初始化数组（把桶清空）\n\t}\n\tint n = 0;//要对n个数排序\n\tprintf(\"请输入需要对几个数进行排序：\");\n\tscanf(\"%d\", &n);//输入n个需要排序的数\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &t);//把数输入到t中\n\t\tbook[t]++;       //进行计数，第t个桶插加一个旗\n\t}\n\tfor (int i = 0; i < 11; i++)   //依此判断编号为0~10的桶，（从小到大）。\n\t{\n\t\tfor (int j = 0; j < book[i]; j++) //出现几个就打印几次\n\t\t{\n\t\t\tprintf(\"%d \", i);\n\t\t}\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n桶排序这种方法存在明显的问题就是占用了太多的空间。假如需要排列的数中有一个10000，那么最少得定义数组长度为10000的数组。\n\n### 冒泡排序（BubbleSort）\n\n冒泡排序的思想：\n\n> **每次比较两个相邻的两个数，如果它们的顺序是错误的（要求是从小到大，此时的序列是前面的比后面的大）就把它们进行交换。**如果有n个数进行排序，要进行n-1趟操作，而每一趟比较都要从第一个数开始，两两进行比较，将较大的数，放在后面。重复此步骤直到最后一个尚未归位的数，已经归位的数则无需比较。\n\n排序过程：\n\n> 假设我们现在对12,35,99,18,76这几个数由大到小进行排序。也就是前面的数比后面的大。\n>\n> 把1个位归位成为跑一趟\n>\n> 第一趟：\n>\n> 首先，比较12和35，发现12小于35，那么要交换这两个数。得到35,12,99,18,76.\n>\n> 然后，继续比较第二位和第三位，发现12比99小，交换得到，35,99,12,18,76.\n>\n> 接着，比较第三位和第四位，发现12小于18，交换得到，35,99,18,12,76.\n>\n> 最后，比较第四位和第五位，发现12小于76，交换得到，35,99,18,76,12.\n>\n> 四次比较后，发现最小的数12已经归位。然而这还只是把1个数归位了。接下来归位剩余的四个数。\n>\n> 第二趟：\n>\n> 现在归位第次小的数，跟第一趟过程差不多。\n>\n> 首先，比较35和99，发现小，那么交换之，得到99,35,18,76,12.\n>\n> ···\n>\n> 因为12已经归位了，所以没有必要比较第四位和第五位的大小。\n>\n> ...\n>\n> 这趟完成后，次小的数也已经归位了\n>\n> 第三趟：\n>\n> ···\n>\n> 第四趟：\n>\n> ···\n>\n> 直到得到最后的序列\n\n{% asset_img 冒泡排序.png  冒泡排序%}\n\n排序的原理：\n\n> 如果有n 个数进行排序，只需将n-1 个数归位，也就是说要进行n-1 趟操作。而“每一趟”都需要从第1 位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一个尚未归位的数，已经归位的数则无需再进行比较.\n\n代码描述：\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n\tint arr[100];\n\tint n = 0;//需要对n个数进行排序(从小到大)\n\tint temp = 0;\n\tprintf(\"请输入需要对几个数进行排序:\");\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &arr[i]);\n\t}\n\n\t//冒泡排序:\n\n\t//先分开写：\n\t////第一趟：\n\t//for (int i = 0; i < n -1; i++)\n\t//{\n\t//\tif (arr[i]>arr[i + 1]){\n\t//\t\ttemp = arr[i];\n\t//\t\tarr[i] = arr[i + 1];\n\t//\t\tarr[i + 1] = temp;\n\t//\t}\n\t//}\n\t////第二趟：\n\t//for (int i = 0; i < n - 2; i++)\n\t//{\n\t//\tif (arr[i]>arr[i + 1]){\n\t//\t\ttemp = arr[i];\n\t//\t\tarr[i] = arr[i + 1];\n\t//\t\tarr[i + 1] = temp;\n\t//\t}\n\t//}\n\t////需要 n-1 趟\n\t////...\n\t\n\t\n\t//合并起来：\n\tfor (int times = 1; times <= n - 1; times++){\n\t\tfor (int i = 0; i < n - times; i++){\n\t\t\tif (arr[i]>arr[i + 1]){\n\t\t\t\ttemp = arr[i]; //交换的过程\n\t\t\t\tarr[i] = arr[i+1];\n\t\t\t\tarr[i+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\n\t//打印排好序的数组\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%d \", arr[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 快速排序（QuickSort）\n\n快速排序的过程：\n\n> 我们对需要排序的序列6 1 2 7 9 3 4 5 10 8 ，首先在这组数中找一个基准数，我们就把第一个数6作为基准数，接下来，需要将这个序列中所有比基准数大的数放在6 的右边，比基准数小的数放在6 的左边。\n>\n> 分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6 的数，再从左往右找一个大于6 的数，然后交换它们。这里可以用两个 变量i 和j，分别指向序列最左边和最右边。 \n>\n> 其实哨兵j 的使命就是要找小于基准数的数，而哨兵i 的使命就是要找大于基准数的数，直到i 和j 碰头为止。 \n\n{% asset_img 快速排序1.png  快速排序1%}\n\n{% asset_img 快速排序2.png  快速排序2%}\n\n{% asset_img 快速排序3.png  快速排序3%}\n\n此时，基准数6已经归位，左边的序列是3 1 2 5 4 右边的是 9 7 10 8 ，接下来分别处理这两个序列。处理方法跟上述类似。\n\n其实快速排序的每一轮处理都是将这一轮的基准数归位，直到所有的数归位为止。\n\n{% asset_img 快速排序4.png  快速排序4%}\n\n\n\n代码流程：\n\n> 1.将需要排序的序列放在一个数组中调用排序算法\n>\n> 2.设置哨兵i和j和基准数。\n>\n> 3.哨兵j先走，哨兵j找出小于基准数的值，哨兵i找出大于基准数的数。\n>\n> 4.若i和j没要到则交换这两个数。反之，将基准数归位，即交换arr[i]和基准数。\n>\n> 5.一轮完成后，剩下的就是将左边后右边的序列进行递归调用快速排序方法，直到将所有子序列排列完成为止。\n>\n> 6.输出排好序的数组\n\n代码实现：\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n//分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6 的数，再从左往右找一个大于6 的数，然后交换它们。这里可以用两个\n//变量i 和j，分别指向序列最左边和最右边。\n\n//其实哨兵j 的使命就是要找小于基准数的数，而哨兵i 的使命就是要找大于基准数的数，直到i 和j 碰头为止。\n\n/*快速排序的每一轮处理其实就是将这\n一轮的基准数归位，直到所有的数都归位为止，排序就结束了。\n*/\nvoid qSort(int left, int right,int arr[])\n{\n\tint i, j, temp, basic;\n\tif (left > right)\n\t\treturn;\n\ti = left;    //哨兵i和j分别指向left和right\n\tj = right;\n\tbasic = arr[left];//基准数\n\twhile (i != j){\n\t\t//哨兵j先走，要有顺序，因为此处设置的基准数是最左边的数\n\t\twhile (arr[j] >= basic && i < j){//哨兵j的使命就是找出小于基准数的数\n\t\t\tj--;\n\t\t}\n\t\twhile (arr[i] <= basic && i < j){//哨兵i的使命就是找出大于基准数的数\n\t\t\ti++;\n\t\t}\n\t\t//i和j没遇到，交换着两个值\n\t\tif (i < j){\n\t\t\ttemp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t}\n\t}\n\t//i和j相遇，将基准值归位.\n\t//上面有了代码 basic = arr[left]  ，basic这时候就是一个临时变量\n\tarr[left] = arr[i];\n\tarr[i] = basic;\n\n\t//把基准值归位后就进行 基准值左边和基准值右边部分 的 递归排序\n\tqSort(left, i - 1, arr);\n\tqSort(i + 1, right, arr);\n}\nint main(){\n\tint arr[] = {6,1,2,7,9,3,4,5,10,8};\n\tqSort(0,9,arr);\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tprintf(\"%d \", arr[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 参考书\n\n《啊哈！算法》","tags":["算法"],"categories":["algorithm"]},{"title":"条件和循环语句","url":"/2018/09/29/C_分支和循环结构/","content":"\n分支语句和循环语句是编程的基础中的基础。肯定得熟练掌握！\n\n<!--more-->\n\n> 分支语句：\n>\n> - if\n> - switch\n>\n> 循环语句：\n>\n> - while\n> - for\n> - do while\n\n## 分支语句\n\n### if语句\n\n```C\nif(表达式)\n    语句；\nelse\n\t语句；\n\t\nif(表达式)\n    语句；\nelse if(表达式)\n    语句；\nelse\n\t语句；\n```\n\n> C语言中，0表示假，非0表示真；\n>\n> else 与最近的if配套；\n\n例：\n\n```C\ninclude <stdio.h>\nint main()\n{\n    int num = 3;\n    if(num % 2 == 0){\n        printf(\"% 是偶数\",num);\n    }else{\n        printf(\"% 是奇数\",num);\n    }\n    return 0;\n}\n```\n\n### switch语句\n\nswitch语句也是一种分支语句。 常常用于多分支的情况。并且可以嵌套使用。\n\n语法：\n\n```C\nswitch(整形表达式)\n{\n    case 整形表达式 ： 语句；\n        break；\n    case 整形表达式2 ：语句；\n        break；\n    default：//如果case都不匹配，则执行default内的语句\n        语句；\n        break；\n}\n```\n\n例：\n\n```C\n#include <stdio.h>\nint main()\n{\n\tint day = 0;\n\tswitch(day)\n\t{\n\tcase 1：\n\t\tprintf(\"星期一\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\"星期二\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tprintf(\"星期三\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tprintf(\"星期四\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tprintf(\"星期五\\n\");\n\t\tbreak;\n\tcase 6:\n\t\tprintf(\"星期六\\n\");\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\"星期天\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n```\n\n\n\n## 循环语句\n\n### while循环\n\n语法：\n\n````C\nwhile(循环条件)\n    循环语句；\n````\n\n例如：\n\n> 打印1-10的数字\n\n```C\n#include <stdio.h>\nint main()\n{\n    int i = 1;\n    while(i<=10){\n        printf(\"%d \",i);\n        i += 1;\n    }\n    return 0;\n}\n```\n\n#### while语句中的break和continue\n\nbreak：停止循环，跳出循环，执行循环下面语句；\n\ncontinue ： 跳过本次循环，执行下一次循环；\n\n### for循环\n\n语法：\n\n```C\nfor(变量初始化；变量条件判断；变量调整部分)\n{\n    循环体；\n}\n```\n\n```C\n#include <stdio.h>\nint main()\n{\n\tint i = 0;\n\t//for(i=1/*初始化*/; i<=10/*判断部分*/; i++/*调整部分*/)\n\tfor(i=1; i<=10; i++)\n\t{\n\t\tprintf(\"%d \", i);\n\t}\t\n\treturn 0;\n}\n```\n\n```C\n#include <stdio.h>\nint main()\n{\n    //死循环\n    for(;;)\n    {\n        printf(\"11\");\n    }\n    //双重变量\n    int x = 0;\n    int y = 0；\n    for(x = 0,y = 0;x<2,y<5;++x,y++)\n    {\n        printf(\"111\");\n    }\n    return 0;\n}\n```\n\n### do while 循环\n\n语法:\n\n```C\ndo\n{\n    循环体；\n    变量调整；\n}while(循环条件)\n```\n\n可以看出，循环至少执行一次。先执行循环体，在进行判断是否还可以循环。\n\n### 应用 ：折半查找算法\n\n```C\nint bin_search(int arr[],int left,int right,int key )\n{\n    int mid = 0;\n    while (left <= right)\n    {\n        mid = (left+right)/2;\n        if(arr[mid]>key)\n        {\n            right = mid - 1;//猜大了\n        }\n        else if (arr[mid] < key)\n        {\n            left = mid +1;//猜小了\n        }\n        else \n        {\n            return mid;//找到了\n        }\n    }\n    return -1;//没找到或者直接没进入循环。\n}\n```\n\n\n\n### goto语句\n\n语法:\n\n```C\ngoto loop;\n\nloop:\n\t代码块;\n```\n\n> 最常见的用法就是终止程序在某些深度嵌套的结构的处理过程， 例如一\n> 次跳出两层或多层循环。这种情况使用break是达不到目的的。 它只能从最内层循环退出到上一层的循环。\n\n```C\nfor()\n{\n    for()\n    {\n        for()\n        {\n            if(条件)\n                goto error;\n        }\n    }\n}\n\nerror:\n\tif(..)\n        ...\n```\n\n\n\n**写一个关机程序**\n\n```C\n#include <stdio.h>\nint main()\n{\n    char input[10];\n    sysytem(\"shutdown -s -t 60\");\n again:\n    printf(\"电脑将在1分钟内关机，输入\"我是猪\"就取消关机\\n\");\n    scanf(\"%s\"，input);\n    if(strcpm(input,\"我是猪\") == 0)\n    {\n        system(\"shutdown -a\");\n    }\n    else\n    {\n        goto again;\n    }\n    return 0;\n}\n```\n\n","tags":["C语言"],"categories":["lang"]},{"title":"C--Test01","url":"/2018/09/26/C语言练习1/","content":"\n\n\n##  交换两变量的值\n\n>  题目：给定两个整形变量的值，将两个值的内容进行交换。\n\n这可以使用指针变量进行交换。切不可直接接交换\n\n<!--more-->\n\n```C\n有两种思想，看看哪组正确？\n//参数为指针变量\nvoid swap(int* x, int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n//参数为普通变量\nvoid swap(int x, int y){\n\tint temp = 0;\n\ttemp = x;\n\tx = y;\n\ty = temp;\n}\n```\n\n图解：\n\n用指针的话，显然在内存二者已经交换了！\n\n{% asset_img 指针.png  用指针 %}\n\n但是，当不用指针的话，两组变量都有自己独立的内存空间，没有产生关联，当然num1和num2没有在内存中发生交换。\n\n{% asset_img 非指针.png  不用指针 %}\n\n那么，这时候只要给swap函数传两个参数即可进行交换。\n\n代码为：\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n//给定两个整形变量的值，将两个值的内容进行交换。\nvoid swap(int* x, int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\nint main(){\n\tint num1 = 2;\n\tint num2 = 8;\n\tprintf(\"num1=%d num2=%d\\n\",num1,num2);\n\tswap(&num1, &num2);\n\tprintf(\"num1=%d num2=%d\\n\",num1,num2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n> 题目：不允许创建临时变量，交换两个数的内容\n\n首先，可以使用两变量之和或者差、积等促成一个临时变量。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//不允许创建临时变量，交换两个数的内容\nint main()\n{\n\tint a = 0;\n\tint b = 0;\n\tprintf(\"请输入两个数：\");\n\tscanf(\"%d,%d\", &a,&b);\n\tprintf(\"交换前：\\n\");\n\tprintf(\"a = %d\\nb = %d\\n\",a,b);\n\ta = a + b;  \n\tb = a - b; //原来的a\n\ta = a - b;//a减去原来的a就是原来的b\n \tprintf(\"交换后: \\n\");\n\tprintf(\"a = %d\\nb = %d\\n\", a, b);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n> 上述方法有一个明显的缺陷，就是当a和b足够大时a+b可能int类型存不下发生溢出现象\n\n解决办法：按位异或（^）\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//不允许创建临时变量，交换两个数的内容(按位异或)\nint main()\n{\n\tint a = 0;\n\tint b = 0;\n\tprintf(\"请输入两个数：\");\n\tscanf(\"%d,%d\", &a,&b);\n\tprintf(\"交换前：\\n\");\n\tprintf(\"a = %d\\nb = %d\\n\",a,b);\n\t//\ta 010  //b\n\t//\tb 101 //\n\t//    111 //a\n\ta = a^b;\n\tb = a^b;//原来的a\n\ta = a^b;//a异或原来的a就是原来的b\n \tprintf(\"交换后: \\n\");\n\tprintf(\"a = %d\\nb = %d\\n\", a, b);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n>  这个方法就不会发生溢出现象。但是实际并不提倡，因为效率较低！ok\n\n> 题目： 将数组A中的内容和数组B中的内容进行交换。（数组一样大）\n\n一样的思路，用一个交换函数swap进行操作！\n\n> 注意点：这里传的是数组每一项的地址，如&a[5]；\n>\n> 还有，尽可能的把功能单独出来作为函数。用来调用！\n>\n> C语言中数组的长度计算为：sizeof(x)/sizeof(x[0])  其中sizeof计算的是多少个字节，然后除以第一项所占的字节就是数组的长度。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n#define arr_length(x) sizeof(x)/sizeof(x[0])\n//将数组A中的内容和数组B中的内容进行交换。（数组一样大） \n\n//交换函数\nvoid swap(int* x,int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n//打印数组\nvoid PrintArrays(int arr[],int length){\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (i == 0){\n\t\t\tprintf(\"[%d,\",arr[0]);\n\t\t}\n\t\tif (i < length - 1){\n\t\t\tprintf(\"%d,\", arr[i]);\n\t\t}else{\n\t\t\tprintf(\"%d]\", arr[i]);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n//给数组输入值\nvoid ScanfArrays(int arr[], int length){\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tscanf(\"%d\", &arr[i]);\n\t}\n}\nint main(){\n\tint A[5];\n\tint B[5];\n\n\tprintf(\"请输入5个数存于A数组中:\");\n\tScanfArrays(A, arr_length(A));\n\tprintf(\"请输入5个数存于B数组中:\");\n\tScanfArrays(B, arr_length(B));\n\n\tprintf(\"交换前的A数组:\");\n\tPrintArrays(A, arr_length(A));\n\tprintf(\"交换前的B数组:\");\n\tPrintArrays(B, arr_length(B));\n\n\t//交换A和B数组\n\tfor (int index = 0; index < 5; index++)\n\t{\n\t\tswap(&A[index],&B[index]);\n\t}\n\n\tprintf(\"交换后的A数组:\");\n\tPrintArrays(A, arr_length(A));\n\tprintf(\"交换后的B数组:\");\n\tPrintArrays(B, arr_length(B));\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n## 求10个整数中最大值\n\n>  题目：求10个整数中最大值\n\n思路：将这10个数存到一个数组里面，从这数组中找到最大的值就ok了。假设数组中第一个元素为最大值max，遍历整个数组跟这个最大值max进行比较，若有更大的值那么就把大的值赋给max。\n\n\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//3.求10 个整数中最大值。\nint main(){\n\tint arr[10];\n\tint i = 0;\n\tprintf(\"请输入10个数,用\\\",\\\"隔开:\");\n\tfor ( i = 0; i < 10; i++)\n\t{\n\t\tscanf(\"%d,\",&arr[i]);\n\t}\n\tint max = arr[0];\n\tfor (i = 1; i < 10; i++)\n\t{\n\t\tif (arr[i]>max)\n\t\t\tmax = arr[i];\n\t}\n\tprintf(\"max=%d\\n\", max);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n## 求两个数的最大公约数\n\n> 题目：求两个数的最大公约数\n\n最大公约数有很多种求法：例如辗转相除法、辗转相减法等等。这次我用的是辗转相除法。方法就是用较大数模较小数得到的余数，然后用较小数模这个余数，以此类推直到余数等于零，那么这时候的较小数就是两数的最大公约数。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n//求两个数的最大公约数\n\nint main(){\n\tint num1, num2;\n\tint temp;\n\tprintf(\"请输入两个数：\");\n\tloop:scanf(\"%d,%d\", &num1, &num2);\n\tif (num2 == 0){\n\t\tprintf(\"你的输入有误,请重新输入\\n\");\n\t\tgoto loop;\n\t}\n\twhile (num1%num2 != 0){ //辗转相除法\n\t\ttemp = num1%num2;\n\t\tnum1 = num2;\n\t\tnum2 = temp;\n\t}\n\tprintf(\"最大公约数为：%d\\n\", num2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n>  相同的，最小公倍数乘以最大公约数等于两数之积。\n\n##  1到 100 的所有整数中出现多少次数字9\n\n>  题目：编写程序数一下 1到 100 的所有整数中出现多少次数字9。\n\n分析：这类题目一定要分步骤来看。个位和十位分别来看，再具体确定判断条件。个位上的9就是9、19 、29、39.....99。模10都等于9；十位上的是90、91、92....99.。注意这把99数了两遍，但是个位数了10位就不会再数了。ok~\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n//编写程序数一下 1到 100 的所有整数中出现多少次数字9。\n//9,19,29,39....   90 92 93...\n\nint main(){\n\tint count = 0;\n\tfor (int i = 1; i < 100; i++){\n\t\tif (i%10 == 9){ //个位有9的数，包括了99\n\t\t\tcount += 1;\n\t\t}\n\t\tif (i/10 == 9){//十位数有9的数，90~98，99在上面已经数过了。\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tprintf(\"出现9的次数为%d次\\n\", count);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n","tags":["C语言练习"],"categories":["lang"]},{"title":"素数计算","url":"/2018/09/21/C_计算素数/","content":"\n\n\n## 1.打印100~200之间的素数\n\n>  素数：当一个数的因子只有1和它本身的时候就是素数。特殊也是最小的质数是2。\n\n<!---more-->\n\n> 分析 ：一般的，拿一个数n(n!=2)除以2，除以3，直达除到n-1，若可以整除，说明n为质数,反之非质数\n>\n> 当然，也不是一点得除到n-1，其实到n/2都可以了。\n>\n> 甚至，其实到根号n都可以了。\n>\n> 还有，除了2偶数都不可能是质数，那直接把偶数排除掉 for(i = 3;i<n/2;i+=2)\n\n```C\n#include<stdio.h>\n\n//求100-200之间的素数；\nint main()\n{\n\tint count = 0;\n\tfor (int i = 100; i <= 200; i++)\n\t{\n\t\tif (IsPrime(i)){\n\t\t\tcount++;\n\t\t\tprintf(\" %d \", i);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"%d\", count);\n\treturn 0;\n}\nint IsPrime(int n)  //判断一个数是否为素数\n{\n\tif (n <= 1){\n\t\treturn 0;\n\t}\n\tif (n == 2){\n\t\treturn 1;\n\t}\n\tfor (int i = 2; i < n; i++){\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n```\n\n>  [作为参考](https://blog.csdn.net/PriestessofBirth/article/details/79435124),等到后面研究算法的时候可能有更加优化的方案！\n\n\n\n## 2.输出乘法口诀表\n\n>  用一对嵌套for循环可以轻易实现，注意格式化打印\n\n```C\n#include <stdio.h>\n//打印乘法口诀表\nint main()\n{\n\tfor (int i = 1; i < 10; i++){\n\t\tfor (int j = 1 ; j<= i ; j++)\n\t\t{\n\t\t\tprintf(\"%d*%d=%d\\t\",j,i,i*j);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n结果：{% asset_img 乘法口诀表.png  乘法口诀表%}\n\n##  3.判断1000~2000年之间的闰年\n\n>  闰年判断条件：四年一闰，一百年不闰。四百年又一闰。\n\n```c\n#include <stdio.h>\n//判断1000年---2000年之间的闰年\nint main(){\n\tint count = 0;\n\tfor (int i = 1000; i <= 2000; i++)\n\t{\n\t\tif (IsLeapYear(i)){\n\t\t\tprintf(\"%d \", i);\n\t\t\tcount++;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"闰年有%d个\\n\",count);\n\treturn 0;\n}\nint IsLeapYear(int year){\n\tif ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n\n{% asset_img 判断闰年.png  判断闰年 %}","tags":["C语言练习"],"categories":["lang"]},{"title":"先定一个小目标~","url":"/2018/09/21/先定一个小目标~/","content":"\n先做一个自我介绍，我叫史腾飞，好就这样！\n大三了，大学时间已经过半了，不是感叹时间过得太快了，但是我也不能掉队呀！\n\n- 学习编程，代码量尤为重要。所以我可以保证我每天三个小时以上的coding时间。\n- 学习，就要做好笔记，以便于回顾。这也是写博客的主要目的。\n- 杜绝眼高手低。\n- 我会定期制定我的学习计划。\n\n> 做你不想做的事，你会发现也不过如此！\n>\n> 加油！","tags":["Flags"],"categories":["others"]},{"title":"Hexo+GitHub打造个人博客","url":"/2018/09/17/hexo搭建博客/","content":"## 1.准备工作\n1.安装nodejs\n去官网下载nodejs安装(推荐安装4.x),安装之后在命令行 node -v,如果成功说明node环境ok,不成功就去环境变量配置一下.\n2.安装hexo\n使用命令 npm install hexo -g,执行hexo -v 查看版本,本教程适合3.1.1以上版本\n3.安装git\n<!-- more -->\n去官网下载git安装\n4.配置git\n配置ssh私钥,上传到github上\n## 2.github-pages的说明\n- github有两种主页,一种是github-page(个人主页),一种是项目主页,本教程针对个人主页\n- github-page需要将hexo博客发布到repository的master(主干)即可\n- github的个人主页要求repository的名称和username一致，加入username是tom，则repository的名称为tom.github.io\n## 3.使用hexo写博客\n```\n- 新建一个文件夹myblog,\n- 右键git bash here使用git的shell\n- 在shell中输入hexo init,回车执行\n- 在shell中输入hexo g ,回车\n- 在shell中hexo s,回车\n- 去浏览器访问http://localhost:4000,访问到主页,然后在shell中ctrl c停止\n- 在shell中hexo new \"first-blog\",回车\n- 在shell中hexo g ,回车\n- 在shell中hexo s ,回车,在访问\n- ok,在本地测试就没问题了\n```\n## 4.发布到github\n打开项目根部录下的.config.yml,找到deploy,修改如下:\n```\ndeploy:\n - type: git\n   repo: git@github.com:yourname/yourname.github.io.git\n     branch: branch\n  message: message\n```\n## 5.常用命令\n\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\nhexo clean  删除public文件夹\n\n```\n## 6.常见问题\n```\n发布不上去：\nnpm install hexo-deployer-git --save 安装依赖包\n```\n## 7.具体设置\nhexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的；\n- 修改主题\n\n修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。\n如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。\n\n全局的_config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。\n需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。\n\n本文参考了博客：[参考博客](https://geeksblog.cc/hexo-githup-blog.html)","tags":["hexo"],"categories":["others"]},{"title":"线程和并发--基础操作","url":"/2018/09/17/线程和并发--基础操作/","content":"## 概述\n**并发和并行**是即相似又有区别：\n- 并行：指两个或多个事件在同一时刻发生；\n- 并发：指两个或多个事件在同一时间段内发生。\n<!--more-->\n**进程**是指一个内存中运行中的应用程序。每个进程都有自己独立的一块内存空间，一个应用程序可以同时启动多个进程。比如在Windows系统中，一个运行的abc.exe就是一个进程。\n那么我们此时就可以处理同时玩游戏和听音乐的问题了，我们可以设计成两个程序，一个专门负责玩游戏，一个专门负责听音乐。\n但是问题来了，要是要设计一个植物大战僵尸游戏，我得开N个进程才能完成多个功能，这样的设计显然是不合理的。\n更何况大多数操作系统都不需要一个进程访问其他进程的内存空间，也就是说进程之间的通信很不方便。\n此时我们得引入“线程”这门技术，来解决这个问题。\n\n**线程**是指进程中的一个执行任务(控制单元)，一个进程可以同时并发运行多个线程，如：多线程下载软件。\n一个进程至少有一个线程，为了提高效率，可以在一个进程中开启多个执行任务,即多线程。\n多进程：操作系统中同时运行的多个程序。\n多线程：在同一个进程中同时运行的多个任务。\n我们查看Windows环境下的任务管理器：\n  在操作系统中允许多个任务，每一个任务就是一个进程，每一个进程也可以同时执行多个任务，每一个任务就是线程。\n\n**多线程**作为一种多任务、并发的工作方式，当然有其存在优势：\n\n- 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。\n- 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.\n- Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程.\n\n## 用java语言创建进程\n\n```\nimport java.io.IOException;\n//如何用java语言开启一个进程\npublic class ProcessDemo {\n\tpublic static void main(String[] args) throws IOException{\n\t\t//方式一：使用Runtime的exec方法\n\t\tRuntime.getRuntime().exec(\"notepad\");\n\t\t//方式二：使用ProcessBuilder类中的start方法\n\t\tProcessBuilder pb = new ProcessBuilder(\"notepad\");\n\t\tpb.start();\n\t}\n}\n\n```\n## 创建和启动线程\n\n### 方式一：继承Thread类\n\n1. 自定义类继承于Thread类，那么该自定义类就是线程类；\n\n2．覆写run方法，将线程运行的代码存放在run中；\n\n3．创建自定义类的对象，即线程对象；\n\n4．调用线程对象的start方法，启动线程。\n\n```\npackage thread_create;\n//继承方式 创建和启动线程\nclass MusicThread extends Thread{      //MusicThread是线程子类\n\tpublic void run() {               //子类必须重写run()方法\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"听音乐\"+i);\n\t\t}\n\t}\n\t\n}\npublic class ExtendsThreadDemo {\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"玩游戏\"+i);\n\t\t\tif( i == 10){\n\t\t\t\tMusicThread t = new MusicThread();  //创建线程子类的实例\n\t\t\t\tt.start(); //底层也调用了run();  启动线程\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}\n\n```\n\n### 方式二：实现Runnable接口\n\n1．自定义类实现Runnable接口；\n\n2．覆写run方法，线程运行的代码存放在run中；\n\n3．通过Thread类创建线程对象，并将实现了Runnable接口的实现类对象作为参数传递给Thread类的构造器。\n\n4．Thread类对象调用start方法，启动线程。\n```\nclass MusicRunnable implements java.lang.Runnable{         //注意MusicRunnable类不是线程类或者线程子类\n\tpublic void run() {\t\t\t\t\t\t\t\t\t   //接口的实现必须覆盖方法。\t\t\t\t\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"听音乐\"+i);\n\t\t}\n\t}\n}\npublic class ImplementsRunnableDemo {\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"玩游戏\"+i);\n\t\t\tif( i == 10){\n\t\t\t\tRunnable t = new MusicRunnable();        //启动线程必须用线程类对象调用start();\n\t\t\t\tnew Thread(t).start();             //类Thread的一个构造器中Thread(Runnable target)分配新的 Thread 对象。\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 对比两种方法（吃苹果比赛）\n**1、继承Thread类** \n\n```\n/**\n * \t案例:存在50个苹果,现在有请三个童鞋(小A,小B,小C)上台表演吃苹果.\n * \t\t因为A,B,C三个人可以同时吃苹果,此时得使用多线程技术来实现这个案例.\n *\n *       此处程序不合理,ABC每个线程都执行50次,即ABC每个人都吃一次编号50的苹果\n */\nclass Person extends Thread{\n\tprivate  int num= 50;\n\tPerson(String name){\n\t\tsuper(name);\n\t}\n\tpublic void run() {\n\t\tfor(int i = 0;i < 50;i++){\n\t\tif(num > 0)\t\n\t\tSystem.out.println(super.getName()+\"吃了第\"+num--+\"个苹果\");\n\t\t}\n\t}\t\n}\n//使用继承Thread的方式创建线程\npublic class ExtendsDemo {\n\tpublic static void main(String[] args){\n\t\tPerson p1 = new Person(\"A\");\n\t\tp1.start();\n\t\tPerson p2 = new Person(\"B\");\n\t\tp2.start();\n\t\tPerson p3 = new Person(\"C\");\n\t\tp3.start();\n\t}\n}\n\n```\n\n**2、实现Runnable接口** \n\n```\nclass Apple implements Runnable{\n\tprivate int num = 50;\n\tpublic void run(){\n\t\tfor(int i = 0; i< 50 ;i++){\n\t\t\tif(num > 0){\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\"吃了第\"+num--+\"个苹果\");\n\t\t\t}//Thread.currentThread()   返回对当前正在执行的线程对象的引用。\n\t\t}\n\t}\n}\n//使用实现Runnable接口的方式，这种方法可以解决此问题\npublic class ImplementsDemo {\n\tpublic static void main(String[] args){\n\t\tRunnable r = new Apple();\n\t\tnew Thread(r,\"A\").start();\n\t\tnew Thread(r,\"B\").start();\n\t\tnew Thread(r,\"C\").start();\n\t}\n}\n\n```\n\n**对比**\n\n继承方式：\n- java中类是单继承的，如果继承了Thread，该类就不能再有其他的直接父类\n- 从操作上分析，继承方式更简单，获取线程的名字也简单（操作上，简单）\n- 从多线程共享一个资源上分析，**继承方式不能做到**\n\n实现方式\n- java中类可以实现接口，此时该类还可以继承其他类，并且可以实现接口（设计上，更优雅）\n- 从操作上分析，实现方式稍微复杂点，获取线程的名字比较复杂，得使用currentThread()获取当前线程的引用。\n- 从多线程共享一个资源上分析，**实现方式可以做到**。\n\n\n\n"}]