[{"url":"/2018/10/27/生产者消费者模型/","content":"## 生产者和消费者模型\n\n> 线程通信：不同的线程执行不同的任务,如果这些任务有某种关系，各个线程必须要能够通信，从而完成工作。线程通信中的经典问题：**生产者和消费者问题**\n\n### 模型：\n![](https://img2018.cnblogs.com/blog/1296856/201810/1296856-20181027180439160-451000565.png)\n\n这个模型也体现了面向对象的设计理念：**低耦合**\n\n也就是为什么生产者生产的东西为什么不直接给消费者，还有经过一个缓冲区（共享资源区）\n\n这就相当于去包子店吃包子，你要5个包子，老板把5个人包子放在一个盘子中再给你，这个盘子就是一个缓冲区。\n\n**现在模拟一个生产者和消费者模型**\n\n- 生产者生产“李小龙 男”，消费者消费也就是打印出“李小龙 男”\n\n- 生产者生产“狗晗 女”，消费者消费也就是打印出“狗晗 女”\n\n- 要求生产者生产一个，消费者消费一个。也就是缓冲区为1\n\n- 期望结果：\n\n  > 李小龙   男\n  >\n  > 狗晗 女\n  >\n  > 李小龙   男\n  >\n  > 狗晗 女\n  >\n  > ···\n\n### 解决问题\n\n需要创建4个类，分别是生产者，消费者，共享资源类，测试类\n\n- 生产者类实现Runnable接口，覆盖run方法\n\n  ```java\n  public class Producer implements Runnable{\n  \tShareResource resource = null;\n  \tpublic Producer(ShareResource resource){\n  \t\tthis.resource = resource;\n  \t}\n  \t@Override\n  \tpublic void run() {\n  \t\tfor(int i = 0; i < 50;i++){\n  \t\t\tif(i % 2 == 0){\n  \t\t\t\tresource.product(\"李小龙\", \"男\");\n  \t\t\t}else{\n  \t\t\t\tresource.product(\"狗晗\",\"女\");\n  \t\t\t}\n  \t\t}\n  \t}\n  \t\n  }\n  ```\n\n  \n\n- 消费者类实现Runnable接口，覆盖run方法\n\n  ```java\n  public class Consumer implements Runnable {\n  \tShareResource resource = null;\n  \tpublic Consumer(ShareResource resource){\n  \t\tthis.resource = resource;\n  \t}\n  \tpublic void run(){\n  \t\tfor(int i = 0;i < 50;i++){\n  \t\t\tresource.consume();\n  \t\t}\n  \t}\n  }\n  ```\n\n  \n\n- 共享资源类有生产者和消费者两个类的引用\n\n  ```java\n  public class ShareResource {\n  \tprivate String name;\n  \tprivate String sex;\n  \t\n  \tpublic void product(String name,String sex){\n  \t    this.name = name;\n          try{\n              Thread.sleep(10);\n          }catch(Exception e){\n              e.printStackTrace();\n          }\n  \t\tthis.sex = sex;\n  \t}\n  \t\n  \tpublic void consume(){\n          try{\n              Thread.sleep(10);\n          }catch(Exception e){\n              e.printStackTrace();\n          }\n  \t\tSystem.out.println(this.name + \" \" + this.sex);\n  \t}\n  }\n  ```\n\n  \n\n- 测试类可以启动线程\n\n  ```java\n  public class Demo {\n  \tpublic static void main(String[]args){\n  \t\tShareResource resource = new ShareResource();\n  \t\tnew Thread(new Producer(resource)).start();\n  \t\tnew Thread(new Consumer(resource)).start();\n  \t}\n  }\n  ```\n\n运行后发现，结果性别发生了紊乱:\n![](https://img2018.cnblogs.com/blog/1296856/201810/1296856-20181027180548349-1940198542.png)\n\n\n我靠，这我龙哥愿意吗，怎么回事？\n\n就是因为多线程并发同一资源，要把它们的方法用synchronized修饰保证它们生产和消费不同时进行，当你加上synchronized之后:\n\n![](https://img2018.cnblogs.com/blog/1296856/201810/1296856-20181027180600339-861860966.png)\n\n\n确实性别紊乱的问题是解决了，狗晗是高兴了，但是它们并不是交替出现的啊，怎么回事？\n\n你要交替出现，必须一个等着一个啊，你生产完了，你得停下来休息啊，让消费者先消费，等到消费者消费完之后，让消费者把你叫醒再继续生产，消费者就又去休息去了，这个消费者优点类似于吃了睡，睡了在吃一样。\n\n#### wait和notify方法\n\n- wait方法：执行该方法的对象释放同步锁，JVM把该线程存放到**等待池**中，等待其他线程唤醒\n\n- notify方法：唤醒在等待池中的等待的任意一个线程，把线程转移到**锁池**中\n\n- notifyAll方法：唤醒在等待池中等待的所有线程，把线程转移到**锁池**中\n\n  > 等待池：没有机会获取同步锁，只能等待被唤醒，被转移到锁池中。\n  >\n  > 锁池： 当前生产者在生产数据的时候(先拥有同步锁),其他线程就在锁池中等待获取锁.，当线程执行完同步代码块的时候,就会释放同步锁,其他线程开始抢锁的使用权.\n\n又来看这个模型，应该得定义一个判断当前共享资源区是否为空，如果为空，消费者就应该等待生产者生产，当生产者生产 完毕后应该唤醒消费者进行消费。如果不为空，生产者就应该等待消费者，等消费者完毕后再唤醒生产者继续生产\n\n```java\npublic class ShareResource {\n\tprivate String name;\n\tprivate String sex;\n\tprivate boolean isEmpty = true;//判断共享区空和满的一个标志\n\t//生产者生产\n\tsynchronized public void product(String name,String sex){\n\t\ttry {\n\t\t\twhile(!isEmpty){//共享区不空，生产者需要停下等待消费者消费\n\t\t\t\t/**\n\t\t\t\t * this是同步锁(同步监听对象)，wait方法是Object类中 的方法，调用该方法就释放同步锁\n\t\t\t\t * 然后JVM把该线程存放到等待池中，等待其他线程唤醒该线程\n\t\t\t\t * 该方法只能被同步监听对象调用，否则报错IllegalMonitorStateException.\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\tthis.wait();\n\t\t\t}\n\t\t\t//----------开始生产-----------\n\t\t\tthis.name = name;\n\t\t\tThread.sleep(10);\n\t\t\tthis.sex = sex;\n\t\t\t//---------结束生产------------\n\t\t\tisEmpty = false;  //设置共享区为不空\n\t\t\t/**\n\t\t\t * notify方法是唤醒等待池中的随机一个线程，把线程转移到锁池中等待(锁池中有机会获取到锁)\n\t\t\t * notifyAll方法是唤醒等待池中的所有线程，把线程转移到锁池中等待\n\t\t\t * 该方法只能被同步监听对象锁调用，否则报错\n\t\t\t */\n\t\t\tthis.notify();\t//唤醒一个消费者               notify是唤醒其中一个，notifyAll是唤醒全部\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t//消费者消费\n\tsynchronized public void consume(){\n\t\ttry {\n\t\t\twhile(isEmpty){//当共享区为空时，消费者进行等待\n\t\t\t\tthis.wait();\n\t\t\t}\n\t\t\t//------------开始消费-------------\n\t\t\tThread.sleep(30);\n\t\t\tSystem.out.println(name + \" \" + sex);\n\t\t\t//------------结束消费-------------\n\t\t\tisEmpty = true;\n\t\t\tthis.notify();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t} \n}\n```\n\n用synchronized修饰方法，会自动获取锁，自动释放锁。从java5开始使用**Lock机制**取代synchronized代码块和synchronized方法，使用Condition接口对象的await，signal，signalAll方法取代notify，notifyAll，用法还是大同小异\n\n```java\npublic class ShareResource {\n\tprivate String name;\n\tprivate String sex;\n\tprivate boolean isEmpty = true;\n\tprivate final Lock lock = new ReentrantLock();\n\tprivate Condition condition = lock.newCondition();\n\t\n\tpublic void product(String name,String sex){\n\t\tlock.lock();//获取锁\n\t\ttry {\n\t\t\twhile(!isEmpty){//不空，生产者要等待消费者消费\n\t\t\t\tcondition.await();//等待，相当于this.wait();\n\t\t\t}\n\t\t\tthis.name = name;\n\t\t\tThread.sleep(10);\n\t\t\tthis.sex = sex;\n\t\t\t\n\t\t\tisEmpty = false;//把共享区置为不空\n\t\t\tcondition.signal();//唤醒一个线程，相当于this.notify().  signalAll 可以唤醒全部线程\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\tlock.unlock();//释放锁\n\t\t}\n\t}\n\t\n\tpublic void consume(){\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile(isEmpty){//共享区为空，需要等待生产者生产\n\t\t\t\tcondition.await();\n\t\t\t}\n\t\t\t\n\t\t\tThread.sleep(20);\n\t\t\tSystem.out.println(this.name + \" \" + this.sex);\n\t\t\t\n\t\t\tisEmpty = false;\n\t\t\tcondition.signal();\n\t\t\t\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\tlock.unlock();\n\t\t}\n\t}\n}\n\n```\n\n结果就是：\n\n![](https://img2018.cnblogs.com/blog/1296856/201810/1296856-20181027180619478-1215835162.png)\n\n\n**Lock机制**\n\n创建一个Lock接口实现类ReetranLock的对象,进入同步方法后立即加锁，lock.lock();最后释放锁，看API中的典型代码\n![](https://img2018.cnblogs.com/blog/1296856/201810/1296856-20181027180629472-1566879594.png)"},{"title":"浅谈排序算法","url":"/2018/10/20/java集合框架/","content":"\n# java集合框架\n\n## 1.集合框架的由来\n\n### 1.1什么是集合框架？\n\n> 集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法.\n\n<!-- more -->\n\n### 1.2为什么要有集合框架？\n\n> 其实在java2之前，java是没有完整的集合框架的，只有一些简答的容器类比如Vector类、Stack类，HashTable类等等。容器类就是用来存储数据。这里数据只能是引用类型的数据，当然，一说到存储数据很快我们会想到数组，数组是可以存储相同类型，可以是基本类型，也可以是引用类型。\n>\n> 数组也存在很多的弊端：\n>\n> - 数组一旦初始化，长度是固定的，不能再改变了。\n> - 每次使用都得编写操作数组的方法，体现不了java的封装思想。\n>\n> **java把集合框架的类和接口都放在了java.util包中**\n\n## 2.集合体系\n\n{% asset_img 集合体系.png  集合体系%}\n\n{% asset_img 图片1.png  图片1%}\n\n{% asset_img map.png  map%}\n\n## 3.List接口\n\nCollection是存储数据的容器。\n\n{% asset_img list.png  list%}\n\n常用操作方法\n\n```java\n\n增加:\nboolean add(Object e) 将指定元素添加到此向量的末尾,等价于addElement方法。 \nvoid add(int index, Object element)  在此向量的指定位置插入指定的元素。 \nboolean addAll(Collection c) :把c集合中的元素添加到当前集合对象中.\n\n删除:\nObject remove(int index) :删除指定索引位置的元素,并返回删除之后的元素.\nboolean remove(Object o):删除指定的元素.\nboolean removeAll(Collection c):从此集合中移除包含在指定 集合c中的所有元素。 \nboolean retainAll(Collection c):在此集合中仅保留包含在指定 集合c中的元素,求两个集合的交集。 \n\n修改:\nObject set(int index, Object element) :修改当前集合中指定索引位置的元素.\n                   返回被替换的旧的元素.\n\n查询:\nint size()  :返回当前集合中存储几个元素.\nboolean isEmpty():判断当前集合中元素个数是否为0. \nObject  get(int index):查询指定索引位置的元素.\nObject[] toArray():把集合对象转换为Object数组.\n```\n\n### 3.1Vector类\n\n> 集合框架出现之前，有一个容器类就是Vector类，Vector类的底层其实就是一个Object数组 protected Object []  elementData;\n>\n> Vector类现在已经基本上被ArrayList取代了\n\n#### 3.1.1Vector类的存储原理\n\n- 底层是一个Object类型的数组，所以可以存储任意类型的**对象**，注意：集合中只能存储对象，不能存储基本类型的数据。但是java5之后支持了自动装箱操作，可以基本类型的值自动装箱为包装类型，但也存储的是对象.\n- 集合中存储的对象,都是存储的是对象的引用,并不是对象的本身.如下:\n\n```java\n\t\tVector v2 = new Vector();\n\t\tStringBuilder sb = new StringBuilder(\"SSSS\");\n\t\tv2.add(sb);//集合类中存储的对象，存储的是对象的引用，并不是存储的值\n\t\tSystem.out.println(v2);//SSSS\n\t\tsb.append(222);\n\t\tSystem.out.println(v2);//SSSS222\n```\n\n### 3.2Stack类\n\nStack是数据结构的一种，先进先出原则，Stack类继承于Vector类，底层可以用数组存储，也可以用链表来存储，官方建议使用ArrayQueue\n\n```java\nDeque 接口及其实现提供了 LIFO 堆栈操作的更完整和更一致的 set，应该优先使用此 set，而非此类。例如： \n\n   Deque<Integer> stack = new ArrayDeque<Integer>();\n\n```\n\n### 3.3ArrayList类\n\nArrayList类是Java集合框架出现之后用来取代Vector类的。二者底层原理都是基于数组的算法,一模一样.\n\n区别\n\n- Vector:  所有的方法都使用了synchronized修饰符. 线程安全但是性能较低.  适用于多线程环境.\n\n- ArrayList:所有的方法都没有使用synchronized修饰符.  线程不安全但是性能较高.\n\n- 即使以后在多线程环境下,我们也不使用Vector类:  ArrayList list = Collections.synchronizedList(new ArrayList(...)); \n\n   \n\n  在Java7之前,即使使用new ArrayList创建对象,一个元素都不存储,但是在堆空间依然初始化了长度位10的Object数组,没必要. 从Java7开始优化这个设计,new ArrayList,其实底层创建的使用一个空数组.    Object [] elementData = new Object[]{}; 在第一次调用add方法的时候,才会重新去初始化数组.\n\n### 3.4 LinkedList类\n\nLinkedList类是双向链表，单向链表双向队列和栈 的实现类\n\n优势：无论是链表还是队列，它们都擅长操作头和尾，所以在LinkedList中的大多数方法都是xxFirst() \n\n看API会发现，LinkedList中依然存在get(int index)方法，也就是根据索引来确定存储的值，链表中是没有索引的概念的，之所以有这个方法是因为有了集合框架，让LinkedList作为了List接口的实现，没法发只能来实现这个方法，我们也该少用这个方法\n\n### 3.5List接口实现类比较\n\n面向接口编程:\n\n```java\n接口类型  变量 =   new  实现类();List      list = new ArrayList();\n```\n\n三者共同的特点(共同遵循的规范):   \n\n- 1):允许元素重复.  \n-  2):记录元素的先后添加顺序.\n  - Vector类:     底层采用数组结构算法,方法都使用了synchronized修饰,线程安全,但是性能相对于ArrayList较低.\n  - ArrayList类: 底层采用数组结构算法,方法没有使用synchronized修饰,线程不安全,性能相对于Vector较高.ArrayList现在机会已经取代了Vector，为了保证ArrayList的线程安全,List list = Collections.synchronizedList(new ArrayList(...));\n\n## 4.Set接口\n\nSet是Collection子接口，模拟了数学上的集的概念。\n\n特点：\n\n- 不允许元素重复\n- 不会记录元素的添加顺序\n\nSet判断两个对象是否相等用equals,而不是使用==。也就是说两个对象equals比较返回true，Set集合是不会接受这个两个对象的。\n\n### 4.1HashSet类\n\nHashSet是Set接口最常用的一个类，底层采用的是哈希表算法\n\n> 在HashSet中如何判断两个对象相同？\n\n当往集合中添加新的对象，先判断该对象和集合对象中的HashCode值：\n\n- 不等，直接把该对象存储到HashCode 指定的位置\n- 相等，在据需判断新的对象和集合中的equals比较\n\n二者缺一不可\n\n每一个存储到hash表中的对象,都得提供hashCode和equals方法,用来判断是否是同一个对象.存储在哈希表中的对象,都应该覆盖equals方法和hashCode方法,并且保证equals相等的时候,hashCode也应该相等.\n\n### 4.2LinkedHashSet类\n\n顾名思义，底层用的是链表和哈希表算法，链表记录元素的添加顺序，哈希表保证元素不重复。。综合了List接口和Set接口的特点，很强势，但是性能并不高\n\nLinkedHashSet类是HashSet类的子类\n\n### 4.3TreeSet类\n\n底层采用的是红黑树算法，会对存储的元素默认进行自然排序，从小到大。\n\n- 自然排序\n\nTreeSet调用集合元素的compareTo方法来比较元素的大小关系,然后讲集合元素按照升序排列(从小到大).注意:要求TreeSet集合中元素得实现java.util.Comparable接口.覆盖 public int compareTo(Object o)方法,在该方法中编写比较规则.在该方法中,比较当前对象(this)和参数对象o做比较(严格上说比较的是对象中的数据).       this  >  o: 返回正整数.  1       this <   o: 返回负整数.  -1       this == o: 返回0.     此时认为两个对象为同一个对象.\n\n- 定制排序\n\n在创建对象的时候，在TreeSet构造器中传递java.lang.Comparator对象.并覆盖public int compare(Object o1, Object o2)再编写比较规则.\n\n```java\npackage set;\nimport java.util.*;\n/**\n * @author 15626\n *\tTreeSet 底层采用的是是红黑树算法，会对存储的 元素进行自然排序(从小到大)\n *\t要排序当然要保证类型相同，可以使用泛型进行规范\n *\t排序规则：数字就进行比大小，字符就按照Unicode编码规范来比较（前128位与ASCII编码重复）\n */\npublic class TreeSetDemo {\n\n\tpublic static void main(String []args){\n\t\tSet<Student> set = new TreeSet<Student>();\n\t\tset.add(new Student(\"张三\",30));\n\t\tset.add(new Student(\"李四\",20));\n\t\tset.add(new Student(\"王麻子\",10));\n\t\tSystem.out.println(set);\n\t\t\n\t\t\n\t\t/**\n\t\t * 定制排序：在TreeSet构造器中传一个实现Comparator接口类的一个对象，\n\t\t * 在实现类中覆盖Comparator接口中的public int compare(Ojbect o1,Object o2)方法\n\t\t * 在方法中可以编写比较规则 \n\t\t */\n\t\t\n\t\t//定制排序：根据人名长度进行排序\n\t\tSet<Student> set2 = new TreeSet<Student>(new NameLengthComparator());\n\t\tset2.add(new Student(\"张三李四\",30));\n\t\tset2.add(new Student(\"李四\",20));\n\t\tset2.add(new Student(\"王麻子\",10));\n\t\tSystem.out.println(set2);\n\t}\n}\nclass NameLengthComparator implements Comparator<Student>{\n\n\t@Override\n\tpublic int compare(Student o1, Student o2) {\n\t\t// TODO Auto-generated method stub\n\t\tif(o1.name.length()>o2.name.length()){\n\t\t\treturn 1;\n\t\t}else if(o1.name.length() < o2.name.length()){\n\t\t\treturn -1;\n\t\t}else{\n\t\t\treturn 0;    //说明是同一个对象\n\t\t}\n\t}\n\t\n}\nclass Student implements Comparable<Student>{\n\tString name;\n\tint age;\n\t\n\tpublic Student(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Student [name=\" + name + \", age=\" + age + \"]\";\n\t}\n\n\t/* 自然排序：覆盖Comparable接口中的compareTo方法\n\t * this > o ,返回正整数\n\t * this < o ,返回负整数\n\t * this = o ,返回0     //说明两个对象相同\n\t * \n\t */\n\n\t@Override\n\t//自然排序：根据年龄排序\n\t\n\tpublic int compareTo(Student o) {\n\t\tif(this.age > o.age){\n\t\t\treturn 1;      \n\t\t}else if(this.age < o.age){\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n```\n\n### 4.4 Set实现类的比较\n\n共同点：\n\n- 都不允许元素重复\n- 都不是线程安全的类\n\n不同：\n\n- HashSet     不保证元素的先后添加顺序.底层采用的是哈希表算法,查询效率极高. \n  - 判断两个对象是否相等的规则:     \n    - equals比较为true\n    - hashCode值相同.                 \n    - 要求存在在哈希中的对象元素都得覆盖equals和hashCode方法.\n- LinkedHashSet  HashSet的子类,底层也采用的是哈希表算法,但是也使用了链表算法来维持元素的先后添加顺序.  \n  - 判断两个对象是否相等的规则和HashSet相同.  因为需要多使用一个链表俩记录元素的顺序,所以性能相对于HashSet较低.\n- TreeSet   不保证元素的先后添加顺序,但是会对集合中的元素做排序操作，底层采用红黑树算法  \n  -  自然排序:  要求在TreeSet集合中的对象必须实现java.lang.Comparable接口,并覆盖compareTo方法.  \n  - 定制排序:  要求在构建TreeSet对象的时候,传入一个比较器对象(必须实现java.lang.Comparator接口). 在比较器中覆盖compare方法,并编写比较规则.\n  -   TreeSet判断元素对象重复的规则:    compareTo/compare方法是否返回0.如果返回0,则视为是同一个对象.\n\n## 5.Map接口\n\n严格上说,Map并不是集合,而是两个集合之间的映射关系(Map接口并没有继承于Collection接口),然而因为Map可以存储数据(每次存储都应该存储A集合中以一个元素(key),B集合中一个元素(value)),我们还是习惯把Map也称之为集合.\n\nMap接口并没有继承于Collection接口也没有继承于Iterable接口,所以不能直接对Map使用for-each操作.\n\n- 可以把Map中的key看做一个Set集合（不允许重复）\n- 可以吧Map中的value看做一个List集合（允许重复）\n- 可以把Entry（key-value）键值对看做一个Set集合（不允许重复）\n\n如此以来，可以间接的对Map使用for-each\n\n其实，相同算法的Set底层用的是相同算法的Map.  把Set的集合对象作为Map的key,再使用一个Object常量做为value.\n\n### 5.1Map的常用方法\n\n```java\n void clear() \n          从此映射中移除所有映射关系（可选操作）。 \n boolean containsKey(Object key) \n          如果此映射包含指定键的映射关系，则返回 true。 \n boolean containsValue(Object value) \n          如果此映射将一个或多个键映射到指定值，则返回 true。 \n Set<Map.Entry<K,V>> entrySet() \n          返回此映射中包含的映射关系的 Set 视图。 \n boolean equals(Object o) \n          比较指定的对象与此映射是否相等。 \n V get(Object key) \n          返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 \n int hashCode() \n          返回此映射的哈希码值。 \n boolean isEmpty() \n          如果此映射未包含键-值映射关系，则返回 true。 \n Set<K> keySet() \n          返回此映射中包含的键的 Set 视图。 \n V put(K key, V value) \n          将指定的值与此映射中的指定键关联（可选操作）。 \n void putAll(Map<? extends K,? extends V> m) \n          从指定映射中将所有映射关系复制到此映射中（可选操作）。 \n V remove(Object key) \n          如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 \n int size() \n          返回此映射中的键-值映射关系数。 \n Collection<V> values() \n          返回此映射中包含的值的 Collection 视图。 \n\n```\n\n### 5.2HashMap类\n\n采用哈希表算法, 此时Map中的key不会保证添加的先后顺序,key也不允许重复.\n\nkey判断重复的标准是: key1和key2是否equals为true,并且hashCode相等.\n\n### 5.3TreeMap类\n\n采用红黑树算法,此时Map中的key会按照自然顺序或定制排序进行排序,,key也不允许重复.                        key判断重复的标准是: compareTo/compare的返回值是否为0.\n\n### 5.4 LinkedHashMap类\n\n采用链表和哈希表算法,此时Map中的key会保证先后添加的顺序,key不允许重复.  \n\nkey判断重复的标准和HashMap中的key的标准相同.\n\n### 5.5 Hashtable类\n\n采用哈希表算法,是HashMap的前身(类似于Vector是ArrayList的前身)\n\n在Java的集合框架之前,表示映射关系就使用Hashtable.\n\n\n\nHashMap和TreeMap以及LinkedHashMap都是线程不安全的,但是性能较高。\n\n解决方案: Map m = Collections.synchronizedMap(Map对象);\n\n## 6.集合工具类\n\n### 6.1 Arrays类\n\n 在Collection接口中有一个方法叫toArray把集合转换为Object数组.  把集合转换为数组:  Object[] arr = 集合对象.toArray();  \n\n数组也可以转换为集合(List集合):  public static <T> List<T> asList(T... a) 等价于public static <T> List<T> asList(T[] a).\n\n```java\npackage util;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/**\n * @author 15626\n *\t集合的工具类 ：Arrays,可以把数组转换成集合\n */\npublic class ArraysDemo {\n\tpublic static void main(String []args){\n\t\t//把集合转换成数组\n\t\tArrayList<String> list = new ArrayList<>();\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"d\");\n\t\tObject [] arr= list.toArray();\n\t\tfor(Object arr1 : arr){\n\t\t\tSystem.out.println(arr1);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"========================\");\n\t\t\n\t\t//把数组转化成集合\n\t\tString [] str = new String[]{\"A\",\"b\",\"C\"};\n\t\t\n\t\t//返回的是不能改变长度的list对象，因为返回的ArrayList不是java.util.ArrayList包中的对象，而是Arrays类中的内部类对象\n\t\tList<String> list2 = Arrays.asList(str);\n\t\t//list2.remove(0);//UnsupportedOperationExceptions\n\t\tSystem.out.println(list2);\n\t\t\n\t\t//基本类型的数据会自动装箱转化为包装类型，这里的1,2，3都自动装箱为Integer类型\n\t\tList<Integer> list3 = Arrays.asList(1,2,3,4,5);\n\t\tSystem.out.println(list3);\n\t\t\n\t\t//试图把数组直接转化一下,这是直接把数组当做对象，基本类型的数据不能存储到集合中\n\t\tint [] a = new int[]{1,2,3,4,5};\n\t\tList<int[]> list4 = Arrays.asList(a);\n\t\tSystem.out.println(list4);\n\t}\n}\n\n```\n\n### 6.2Collections类\n\n  HashSet/ArrayList/HashMap都是线程不安全的,在多线程环境下不安全.  在Collections类中有获取线程安全的集合方法:\n\n```java\nSet  set = Collections.synchronizedSet(new HashSet());\nMap  map = Collections.synchronizedMap(new HashMap());\nList list = Collections.synchronizedList(new ArrayList());\n```\n\n## 7.泛型\n\n集合框架牵扯到了泛型，这有篇文章对泛型有很详细的解释：https://www.cnblogs.com/coprince/p/8603492.html\n\n## 8.测试代码\n\nhttps://github.com/EarthSoar/JavaExamples/tree/master/CollectionsFramework\n\n","tags":["java"],"categories":["lang"]},{"title":"ArrayList模拟球员上场案列","url":"/2018/10/16/ArrayList模拟球员上场案列/","content":"\n假设我现在是球队的教练,我需要安排上场的球员(安排5个).模拟数据存储的案例,模拟上场球员的球衣号码的存储:        \n\nInteger[] players = null;\n\n作为一个教练,要安排上场:          \n\n<!--more-->\n\n- 1):初始容量为5的线性列表,准备用来存储场上的5个球衣号码.           \n- 2):安排5个球员上场:[11,22,33,44,55].           \n- 3):查询指定位置的球员的球衣号码是多少.查询索引位置为2的球衣号码是:33.           \n- 4):根据球衣号码查询该球员在场上的索引位置. 44球衣号的球员在场上的索引位置是:3.           \n- 5):替换场上索引位置为2的球员,替换之后该位置的球衣编号为333. 333把33替换了.           \n- 6):替换球衣号码为22的球员,替换之后为222.           \n- 7):把场上索引位置为2的球衣罚下场(注意:罚下,没有补位.).           \n- 8):按照球员在场上的位置,打印出球衣号码,打印风格:[11,22,33,44,55].\n\n\n\n代码已经分析：\n\nhttps://github.com/EarthSoar/JavaExamples/tree/master/src/Aarray","tags":["数据结构"],"categories":["algorithm"]},{"title":"浅谈排序算法","url":"/2018/10/08/浅谈排序/","content":"\n排序算法有很多种，今天先谈谈一些简单的排序算法。包括桶排序、冒泡排序和快速排序算法。后期总结各种排序算法。\n\n<!--more-->\n\n### 桶排序（BucketSort）\n\n排序过程：\n\n>  假如我们现在要排序的一组数为：5,3,5,2,8. 这组数都在0-10的范围之内。这个时候，我们可以拿11个桶，标号为0,1,2,3......10。也就是定义长度为11的数组。现在我们来遍历这些数字，第一个数字为5，那么给第五号桶中插一个小红旗，第二个数字为3，给第三号桶插一个小红旗，以此类推。其中，插入一个小红旗代表的是数组元素+1（开始初始化数组元素都为0)，遍历完成之后，可以查看所有桶中小红旗的数量，也就是数组中存储元素的个数。发现a[5] = 2，表示5这个数字出现了两次。从0号桶开始，a[0] = 0,表示没有0这个数字，依次遍历到 10就结束了，也就把这些数字从小到大排好了。\n\n{% asset_img 桶排序.png  桶排序%}\n\n当然，如果需要对0-100之间的数进行排序，就需要101个桶，桶的作用就是一个标志。\n\n把标志数组起个名字为book。\n\n写代码思路：\n\n>1.把book数组初始化，也就是把里面都写成0\n>\n>2.把需要排序的一组数放在一个数组里面。\n>\n>3.循环放入的过程中，对book[i]++。\n>\n>4.依次判断编号为0~10之间的桶中小红旗的个数，即book[i]的值\n>\n>5.有n个小红旗（book[i] = n）就打印n次这个数。\n\n代码如下：\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n//桶排序：对于0~100之间的数排序的时候，这时候需要有101个桶（数组长度为101的数组），插个小旗（加一）用来标记每个数出现的次数。\n//然后，看这些桶中（遍历这个数组）小旗的数目（多少个1），有多少只旗（多少个1）就（打印多少次这个数）表示这个桶的标号（数）出现了几次；\nint main(){\n\tint book[11];//先拿11个桶，0~10之间的数进行排序。\n\tint t = 0;\n\tfor (int i = 0; i < 11; i++)\n\t{\n\t\tbook[i] = 0; //初始化数组（把桶清空）\n\t}\n\tint n = 0;//要对n个数排序\n\tprintf(\"请输入需要对几个数进行排序：\");\n\tscanf(\"%d\", &n);//输入n个需要排序的数\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &t);//把数输入到t中\n\t\tbook[t]++;       //进行计数，第t个桶插加一个旗\n\t}\n\tfor (int i = 0; i < 11; i++)   //依此判断编号为0~10的桶，（从小到大）。\n\t{\n\t\tfor (int j = 0; j < book[i]; j++) //出现几个就打印几次\n\t\t{\n\t\t\tprintf(\"%d \", i);\n\t\t}\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n桶排序这种方法存在明显的问题就是占用了太多的空间。假如需要排列的数中有一个10000，那么最少得定义数组长度为10000的数组。\n\n### 冒泡排序（BubbleSort）\n\n冒泡排序的思想：\n\n> **每次比较两个相邻的两个数，如果它们的顺序是错误的（要求是从小到大，此时的序列是前面的比后面的大）就把它们进行交换。**如果有n个数进行排序，要进行n-1趟操作，而每一趟比较都要从第一个数开始，两两进行比较，将较大的数，放在后面。重复此步骤直到最后一个尚未归位的数，已经归位的数则无需比较。\n\n排序过程：\n\n> 假设我们现在对12,35,99,18,76这几个数由大到小进行排序。也就是前面的数比后面的大。\n>\n> 把1个位归位成为跑一趟\n>\n> 第一趟：\n>\n> 首先，比较12和35，发现12小于35，那么要交换这两个数。得到35,12,99,18,76.\n>\n> 然后，继续比较第二位和第三位，发现12比99小，交换得到，35,99,12,18,76.\n>\n> 接着，比较第三位和第四位，发现12小于18，交换得到，35,99,18,12,76.\n>\n> 最后，比较第四位和第五位，发现12小于76，交换得到，35,99,18,76,12.\n>\n> 四次比较后，发现最小的数12已经归位。然而这还只是把1个数归位了。接下来归位剩余的四个数。\n>\n> 第二趟：\n>\n> 现在归位第次小的数，跟第一趟过程差不多。\n>\n> 首先，比较35和99，发现小，那么交换之，得到99,35,18,76,12.\n>\n> ···\n>\n> 因为12已经归位了，所以没有必要比较第四位和第五位的大小。\n>\n> ...\n>\n> 这趟完成后，次小的数也已经归位了\n>\n> 第三趟：\n>\n> ···\n>\n> 第四趟：\n>\n> ···\n>\n> 直到得到最后的序列\n\n{% asset_img 冒泡排序.png  冒泡排序%}\n\n排序的原理：\n\n> 如果有n 个数进行排序，只需将n-1 个数归位，也就是说要进行n-1 趟操作。而“每一趟”都需要从第1 位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一个尚未归位的数，已经归位的数则无需再进行比较.\n\n代码描述：\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n\tint arr[100];\n\tint n = 0;//需要对n个数进行排序(从小到大)\n\tint temp = 0;\n\tprintf(\"请输入需要对几个数进行排序:\");\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &arr[i]);\n\t}\n\n\t//冒泡排序:\n\n\t//先分开写：\n\t////第一趟：\n\t//for (int i = 0; i < n -1; i++)\n\t//{\n\t//\tif (arr[i]>arr[i + 1]){\n\t//\t\ttemp = arr[i];\n\t//\t\tarr[i] = arr[i + 1];\n\t//\t\tarr[i + 1] = temp;\n\t//\t}\n\t//}\n\t////第二趟：\n\t//for (int i = 0; i < n - 2; i++)\n\t//{\n\t//\tif (arr[i]>arr[i + 1]){\n\t//\t\ttemp = arr[i];\n\t//\t\tarr[i] = arr[i + 1];\n\t//\t\tarr[i + 1] = temp;\n\t//\t}\n\t//}\n\t////需要 n-1 趟\n\t////...\n\t\n\t\n\t//合并起来：\n\tfor (int times = 1; times <= n - 1; times++){\n\t\tfor (int i = 0; i < n - times; i++){\n\t\t\tif (arr[i]>arr[i + 1]){\n\t\t\t\ttemp = arr[i]; //交换的过程\n\t\t\t\tarr[i] = arr[i+1];\n\t\t\t\tarr[i+1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\n\t//打印排好序的数组\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%d \", arr[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 快速排序（QuickSort）\n\n快速排序的过程：\n\n> 我们对需要排序的序列6 1 2 7 9 3 4 5 10 8 ，首先在这组数中找一个基准数，我们就把第一个数6作为基准数，接下来，需要将这个序列中所有比基准数大的数放在6 的右边，比基准数小的数放在6 的左边。\n>\n> 分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6 的数，再从左往右找一个大于6 的数，然后交换它们。这里可以用两个 变量i 和j，分别指向序列最左边和最右边。 \n>\n> 其实哨兵j 的使命就是要找小于基准数的数，而哨兵i 的使命就是要找大于基准数的数，直到i 和j 碰头为止。 \n\n{% asset_img 快速排序1.png  快速排序1%}\n\n{% asset_img 快速排序2.png  快速排序2%}\n\n{% asset_img 快速排序3.png  快速排序3%}\n\n此时，基准数6已经归位，左边的序列是3 1 2 5 4 右边的是 9 7 10 8 ，接下来分别处理这两个序列。处理方法跟上述类似。\n\n其实快速排序的每一轮处理都是将这一轮的基准数归位，直到所有的数归位为止。\n\n{% asset_img 快速排序4.png  快速排序4%}\n\n\n\n代码流程：\n\n> 1.将需要排序的序列放在一个数组中调用排序算法\n>\n> 2.设置哨兵i和j和基准数。\n>\n> 3.哨兵j先走，哨兵j找出小于基准数的值，哨兵i找出大于基准数的数。\n>\n> 4.若i和j没要到则交换这两个数。反之，将基准数归位，即交换arr[i]和基准数。\n>\n> 5.一轮完成后，剩下的就是将左边后右边的序列进行递归调用快速排序方法，直到将所有子序列排列完成为止。\n>\n> 6.输出排好序的数组\n\n代码实现：\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n//分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6 的数，再从左往右找一个大于6 的数，然后交换它们。这里可以用两个\n//变量i 和j，分别指向序列最左边和最右边。\n\n//其实哨兵j 的使命就是要找小于基准数的数，而哨兵i 的使命就是要找大于基准数的数，直到i 和j 碰头为止。\n\n/*快速排序的每一轮处理其实就是将这\n一轮的基准数归位，直到所有的数都归位为止，排序就结束了。\n*/\nvoid qSort(int left, int right,int arr[])\n{\n\tint i, j, temp, basic;\n\tif (left > right)\n\t\treturn;\n\ti = left;    //哨兵i和j分别指向left和right\n\tj = right;\n\tbasic = arr[left];//基准数\n\twhile (i != j){\n\t\t//哨兵j先走，要有顺序，因为此处设置的基准数是最左边的数\n\t\twhile (arr[j] >= basic && i < j){//哨兵j的使命就是找出小于基准数的数\n\t\t\tj--;\n\t\t}\n\t\twhile (arr[i] <= basic && i < j){//哨兵i的使命就是找出大于基准数的数\n\t\t\ti++;\n\t\t}\n\t\t//i和j没遇到，交换着两个值\n\t\tif (i < j){\n\t\t\ttemp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t}\n\t}\n\t//i和j相遇，将基准值归位.\n\t//上面有了代码 basic = arr[left]  ，basic这时候就是一个临时变量\n\tarr[left] = arr[i];\n\tarr[i] = basic;\n\n\t//把基准值归位后就进行 基准值左边和基准值右边部分 的 递归排序\n\tqSort(left, i - 1, arr);\n\tqSort(i + 1, right, arr);\n}\nint main(){\n\tint arr[] = {6,1,2,7,9,3,4,5,10,8};\n\tqSort(0,9,arr);\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tprintf(\"%d \", arr[i]);\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### 参考书\n\n《啊哈！算法》","tags":["算法"],"categories":["algorithm"]},{"title":"条件和循环语句","url":"/2018/09/29/C_分支和循环结构/","content":"\n分支语句和循环语句是编程的基础中的基础。肯定得熟练掌握！\n\n<!--more-->\n\n> 分支语句：\n>\n> - if\n> - switch\n>\n> 循环语句：\n>\n> - while\n> - for\n> - do while\n\n## 分支语句\n\n### if语句\n\n```C\nif(表达式)\n    语句；\nelse\n\t语句；\n\t\nif(表达式)\n    语句；\nelse if(表达式)\n    语句；\nelse\n\t语句；\n```\n\n> C语言中，0表示假，非0表示真；\n>\n> else 与最近的if配套；\n\n例：\n\n```C\ninclude <stdio.h>\nint main()\n{\n    int num = 3;\n    if(num % 2 == 0){\n        printf(\"% 是偶数\",num);\n    }else{\n        printf(\"% 是奇数\",num);\n    }\n    return 0;\n}\n```\n\n### switch语句\n\nswitch语句也是一种分支语句。 常常用于多分支的情况。并且可以嵌套使用。\n\n语法：\n\n```C\nswitch(整形表达式)\n{\n    case 整形表达式 ： 语句；\n        break；\n    case 整形表达式2 ：语句；\n        break；\n    default：//如果case都不匹配，则执行default内的语句\n        语句；\n        break；\n}\n```\n\n例：\n\n```C\n#include <stdio.h>\nint main()\n{\n\tint day = 0;\n\tswitch(day)\n\t{\n\tcase 1：\n\t\tprintf(\"星期一\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\"星期二\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tprintf(\"星期三\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tprintf(\"星期四\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tprintf(\"星期五\\n\");\n\t\tbreak;\n\tcase 6:\n\t\tprintf(\"星期六\\n\");\n\t\tbreak;\n\tcase 7:\n\t\tprintf(\"星期天\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n```\n\n\n\n## 循环语句\n\n### while循环\n\n语法：\n\n````C\nwhile(循环条件)\n    循环语句；\n````\n\n例如：\n\n> 打印1-10的数字\n\n```C\n#include <stdio.h>\nint main()\n{\n    int i = 1;\n    while(i<=10){\n        printf(\"%d \",i);\n        i += 1;\n    }\n    return 0;\n}\n```\n\n#### while语句中的break和continue\n\nbreak：停止循环，跳出循环，执行循环下面语句；\n\ncontinue ： 跳过本次循环，执行下一次循环；\n\n### for循环\n\n语法：\n\n```C\nfor(变量初始化；变量条件判断；变量调整部分)\n{\n    循环体；\n}\n```\n\n```C\n#include <stdio.h>\nint main()\n{\n\tint i = 0;\n\t//for(i=1/*初始化*/; i<=10/*判断部分*/; i++/*调整部分*/)\n\tfor(i=1; i<=10; i++)\n\t{\n\t\tprintf(\"%d \", i);\n\t}\t\n\treturn 0;\n}\n```\n\n```C\n#include <stdio.h>\nint main()\n{\n    //死循环\n    for(;;)\n    {\n        printf(\"11\");\n    }\n    //双重变量\n    int x = 0;\n    int y = 0；\n    for(x = 0,y = 0;x<2,y<5;++x,y++)\n    {\n        printf(\"111\");\n    }\n    return 0;\n}\n```\n\n### do while 循环\n\n语法:\n\n```C\ndo\n{\n    循环体；\n    变量调整；\n}while(循环条件)\n```\n\n可以看出，循环至少执行一次。先执行循环体，在进行判断是否还可以循环。\n\n### 应用 ：折半查找算法\n\n```C\nint bin_search(int arr[],int left,int right,int key )\n{\n    int mid = 0;\n    while (left <= right)\n    {\n        mid = (left+right)/2;\n        if(arr[mid]>key)\n        {\n            right = mid - 1;//猜大了\n        }\n        else if (arr[mid] < key)\n        {\n            left = mid +1;//猜小了\n        }\n        else \n        {\n            return mid;//找到了\n        }\n    }\n    return -1;//没找到或者直接没进入循环。\n}\n```\n\n\n\n### goto语句\n\n语法:\n\n```C\ngoto loop;\n\nloop:\n\t代码块;\n```\n\n> 最常见的用法就是终止程序在某些深度嵌套的结构的处理过程， 例如一\n> 次跳出两层或多层循环。这种情况使用break是达不到目的的。 它只能从最内层循环退出到上一层的循环。\n\n```C\nfor()\n{\n    for()\n    {\n        for()\n        {\n            if(条件)\n                goto error;\n        }\n    }\n}\n\nerror:\n\tif(..)\n        ...\n```\n\n\n\n**写一个关机程序**\n\n```C\n#include <stdio.h>\nint main()\n{\n    char input[10];\n    sysytem(\"shutdown -s -t 60\");\n again:\n    printf(\"电脑将在1分钟内关机，输入\"我是猪\"就取消关机\\n\");\n    scanf(\"%s\"，input);\n    if(strcpm(input,\"我是猪\") == 0)\n    {\n        system(\"shutdown -a\");\n    }\n    else\n    {\n        goto again;\n    }\n    return 0;\n}\n```\n\n","tags":["C语言"],"categories":["lang"]},{"title":"C--Test01","url":"/2018/09/26/C语言练习1/","content":"\n\n\n##  交换两变量的值\n\n>  题目：给定两个整形变量的值，将两个值的内容进行交换。\n\n这可以使用指针变量进行交换。切不可直接接交换\n\n<!--more-->\n\n```C\n有两种思想，看看哪组正确？\n//参数为指针变量\nvoid swap(int* x, int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n//参数为普通变量\nvoid swap(int x, int y){\n\tint temp = 0;\n\ttemp = x;\n\tx = y;\n\ty = temp;\n}\n```\n\n图解：\n\n用指针的话，显然在内存二者已经交换了！\n\n{% asset_img 指针.png  用指针 %}\n\n但是，当不用指针的话，两组变量都有自己独立的内存空间，没有产生关联，当然num1和num2没有在内存中发生交换。\n\n{% asset_img 非指针.png  不用指针 %}\n\n那么，这时候只要给swap函数传两个参数即可进行交换。\n\n代码为：\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n//给定两个整形变量的值，将两个值的内容进行交换。\nvoid swap(int* x, int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\nint main(){\n\tint num1 = 2;\n\tint num2 = 8;\n\tprintf(\"num1=%d num2=%d\\n\",num1,num2);\n\tswap(&num1, &num2);\n\tprintf(\"num1=%d num2=%d\\n\",num1,num2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n> 题目：不允许创建临时变量，交换两个数的内容\n\n首先，可以使用两变量之和或者差、积等促成一个临时变量。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//不允许创建临时变量，交换两个数的内容\nint main()\n{\n\tint a = 0;\n\tint b = 0;\n\tprintf(\"请输入两个数：\");\n\tscanf(\"%d,%d\", &a,&b);\n\tprintf(\"交换前：\\n\");\n\tprintf(\"a = %d\\nb = %d\\n\",a,b);\n\ta = a + b;  \n\tb = a - b; //原来的a\n\ta = a - b;//a减去原来的a就是原来的b\n \tprintf(\"交换后: \\n\");\n\tprintf(\"a = %d\\nb = %d\\n\", a, b);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n> 上述方法有一个明显的缺陷，就是当a和b足够大时a+b可能int类型存不下发生溢出现象\n\n解决办法：按位异或（^）\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//不允许创建临时变量，交换两个数的内容(按位异或)\nint main()\n{\n\tint a = 0;\n\tint b = 0;\n\tprintf(\"请输入两个数：\");\n\tscanf(\"%d,%d\", &a,&b);\n\tprintf(\"交换前：\\n\");\n\tprintf(\"a = %d\\nb = %d\\n\",a,b);\n\t//\ta 010  //b\n\t//\tb 101 //\n\t//    111 //a\n\ta = a^b;\n\tb = a^b;//原来的a\n\ta = a^b;//a异或原来的a就是原来的b\n \tprintf(\"交换后: \\n\");\n\tprintf(\"a = %d\\nb = %d\\n\", a, b);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n>  这个方法就不会发生溢出现象。但是实际并不提倡，因为效率较低！ok\n\n> 题目： 将数组A中的内容和数组B中的内容进行交换。（数组一样大）\n\n一样的思路，用一个交换函数swap进行操作！\n\n> 注意点：这里传的是数组每一项的地址，如&a[5]；\n>\n> 还有，尽可能的把功能单独出来作为函数。用来调用！\n>\n> C语言中数组的长度计算为：sizeof(x)/sizeof(x[0])  其中sizeof计算的是多少个字节，然后除以第一项所占的字节就是数组的长度。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n#define arr_length(x) sizeof(x)/sizeof(x[0])\n//将数组A中的内容和数组B中的内容进行交换。（数组一样大） \n\n//交换函数\nvoid swap(int* x,int* y){\n\tint temp = 0;\n\ttemp = *x;\n\t*x = *y;\n\t*y = temp;\n}\n//打印数组\nvoid PrintArrays(int arr[],int length){\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (i == 0){\n\t\t\tprintf(\"[%d,\",arr[0]);\n\t\t}\n\t\tif (i < length - 1){\n\t\t\tprintf(\"%d,\", arr[i]);\n\t\t}else{\n\t\t\tprintf(\"%d]\", arr[i]);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n//给数组输入值\nvoid ScanfArrays(int arr[], int length){\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tscanf(\"%d\", &arr[i]);\n\t}\n}\nint main(){\n\tint A[5];\n\tint B[5];\n\n\tprintf(\"请输入5个数存于A数组中:\");\n\tScanfArrays(A, arr_length(A));\n\tprintf(\"请输入5个数存于B数组中:\");\n\tScanfArrays(B, arr_length(B));\n\n\tprintf(\"交换前的A数组:\");\n\tPrintArrays(A, arr_length(A));\n\tprintf(\"交换前的B数组:\");\n\tPrintArrays(B, arr_length(B));\n\n\t//交换A和B数组\n\tfor (int index = 0; index < 5; index++)\n\t{\n\t\tswap(&A[index],&B[index]);\n\t}\n\n\tprintf(\"交换后的A数组:\");\n\tPrintArrays(A, arr_length(A));\n\tprintf(\"交换后的B数组:\");\n\tPrintArrays(B, arr_length(B));\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n## 求10个整数中最大值\n\n>  题目：求10个整数中最大值\n\n思路：将这10个数存到一个数组里面，从这数组中找到最大的值就ok了。假设数组中第一个元素为最大值max，遍历整个数组跟这个最大值max进行比较，若有更大的值那么就把大的值赋给max。\n\n\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\n//3.求10 个整数中最大值。\nint main(){\n\tint arr[10];\n\tint i = 0;\n\tprintf(\"请输入10个数,用\\\",\\\"隔开:\");\n\tfor ( i = 0; i < 10; i++)\n\t{\n\t\tscanf(\"%d,\",&arr[i]);\n\t}\n\tint max = arr[0];\n\tfor (i = 1; i < 10; i++)\n\t{\n\t\tif (arr[i]>max)\n\t\t\tmax = arr[i];\n\t}\n\tprintf(\"max=%d\\n\", max);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n## 求两个数的最大公约数\n\n> 题目：求两个数的最大公约数\n\n最大公约数有很多种求法：例如辗转相除法、辗转相减法等等。这次我用的是辗转相除法。方法就是用较大数模较小数得到的余数，然后用较小数模这个余数，以此类推直到余数等于零，那么这时候的较小数就是两数的最大公约数。\n\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n//求两个数的最大公约数\n\nint main(){\n\tint num1, num2;\n\tint temp;\n\tprintf(\"请输入两个数：\");\n\tloop:scanf(\"%d,%d\", &num1, &num2);\n\tif (num2 == 0){\n\t\tprintf(\"你的输入有误,请重新输入\\n\");\n\t\tgoto loop;\n\t}\n\twhile (num1%num2 != 0){ //辗转相除法\n\t\ttemp = num1%num2;\n\t\tnum1 = num2;\n\t\tnum2 = temp;\n\t}\n\tprintf(\"最大公约数为：%d\\n\", num2);\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n>  相同的，最小公倍数乘以最大公约数等于两数之积。\n\n##  1到 100 的所有整数中出现多少次数字9\n\n>  题目：编写程序数一下 1到 100 的所有整数中出现多少次数字9。\n\n分析：这类题目一定要分步骤来看。个位和十位分别来看，再具体确定判断条件。个位上的9就是9、19 、29、39.....99。模10都等于9；十位上的是90、91、92....99.。注意这把99数了两遍，但是个位数了10位就不会再数了。ok~\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n//编写程序数一下 1到 100 的所有整数中出现多少次数字9。\n//9,19,29,39....   90 92 93...\n\nint main(){\n\tint count = 0;\n\tfor (int i = 1; i < 100; i++){\n\t\tif (i%10 == 9){ //个位有9的数，包括了99\n\t\t\tcount += 1;\n\t\t}\n\t\tif (i/10 == 9){//十位数有9的数，90~98，99在上面已经数过了。\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tprintf(\"出现9的次数为%d次\\n\", count);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n","tags":["C语言练习"],"categories":["lang"]},{"title":"素数计算","url":"/2018/09/21/C_计算素数/","content":"\n\n\n## 1.打印100~200之间的素数\n\n>  素数：当一个数的因子只有1和它本身的时候就是素数。特殊也是最小的质数是2。\n\n<!---more-->\n\n> 分析 ：一般的，拿一个数n(n!=2)除以2，除以3，直达除到n-1，若可以整除，说明n为质数,反之非质数\n>\n> 当然，也不是一点得除到n-1，其实到n/2都可以了。\n>\n> 甚至，其实到根号n都可以了。\n>\n> 还有，除了2偶数都不可能是质数，那直接把偶数排除掉 for(i = 3;i<n/2;i+=2)\n\n```C\n#include<stdio.h>\n\n//求100-200之间的素数；\nint main()\n{\n\tint count = 0;\n\tfor (int i = 100; i <= 200; i++)\n\t{\n\t\tif (IsPrime(i)){\n\t\t\tcount++;\n\t\t\tprintf(\" %d \", i);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"%d\", count);\n\treturn 0;\n}\nint IsPrime(int n)  //判断一个数是否为素数\n{\n\tif (n <= 1){\n\t\treturn 0;\n\t}\n\tif (n == 2){\n\t\treturn 1;\n\t}\n\tfor (int i = 2; i < n; i++){\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n```\n\n>  [作为参考](https://blog.csdn.net/PriestessofBirth/article/details/79435124),等到后面研究算法的时候可能有更加优化的方案！\n\n\n\n## 2.输出乘法口诀表\n\n>  用一对嵌套for循环可以轻易实现，注意格式化打印\n\n```C\n#include <stdio.h>\n//打印乘法口诀表\nint main()\n{\n\tfor (int i = 1; i < 10; i++){\n\t\tfor (int j = 1 ; j<= i ; j++)\n\t\t{\n\t\t\tprintf(\"%d*%d=%d\\t\",j,i,i*j);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n结果：{% asset_img 乘法口诀表.png  乘法口诀表%}\n\n##  3.判断1000~2000年之间的闰年\n\n>  闰年判断条件：四年一闰，一百年不闰。四百年又一闰。\n\n```c\n#include <stdio.h>\n//判断1000年---2000年之间的闰年\nint main(){\n\tint count = 0;\n\tfor (int i = 1000; i <= 2000; i++)\n\t{\n\t\tif (IsLeapYear(i)){\n\t\t\tprintf(\"%d \", i);\n\t\t\tcount++;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"闰年有%d个\\n\",count);\n\treturn 0;\n}\nint IsLeapYear(int year){\n\tif ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n\n{% asset_img 判断闰年.png  判断闰年 %}","tags":["C语言练习"],"categories":["lang"]},{"title":"先定一个小目标~","url":"/2018/09/21/先定一个小目标~/","content":"\n先做一个自我介绍，我叫史腾飞，好就这样！\n大三了，大学时间已经过半了，不是感叹时间过得太快了，但是我也不能掉队呀！\n\n- 学习编程，代码量尤为重要。所以我可以保证我每天三个小时以上的coding时间。\n- 学习，就要做好笔记，以便于回顾。这也是写博客的主要目的。\n- 杜绝眼高手低。\n- 我会定期制定我的学习计划。\n\n> 做你不想做的事，你会发现也不过如此！\n>\n> 加油！","tags":["Flags"],"categories":["others"]},{"title":"Hexo+GitHub打造个人博客","url":"/2018/09/17/hexo搭建博客/","content":"## 1.准备工作\n1.安装nodejs\n去官网下载nodejs安装(推荐安装4.x),安装之后在命令行 node -v,如果成功说明node环境ok,不成功就去环境变量配置一下.\n2.安装hexo\n使用命令 npm install hexo -g,执行hexo -v 查看版本,本教程适合3.1.1以上版本\n3.安装git\n<!-- more -->\n去官网下载git安装\n4.配置git\n配置ssh私钥,上传到github上\n## 2.github-pages的说明\n- github有两种主页,一种是github-page(个人主页),一种是项目主页,本教程针对个人主页\n- github-page需要将hexo博客发布到repository的master(主干)即可\n- github的个人主页要求repository的名称和username一致，加入username是tom，则repository的名称为tom.github.io\n## 3.使用hexo写博客\n```\n- 新建一个文件夹myblog,\n- 右键git bash here使用git的shell\n- 在shell中输入hexo init,回车执行\n- 在shell中输入hexo g ,回车\n- 在shell中hexo s,回车\n- 去浏览器访问http://localhost:4000,访问到主页,然后在shell中ctrl c停止\n- 在shell中hexo new \"first-blog\",回车\n- 在shell中hexo g ,回车\n- 在shell中hexo s ,回车,在访问\n- ok,在本地测试就没问题了\n```\n## 4.发布到github\n打开项目根部录下的.config.yml,找到deploy,修改如下:\n```\ndeploy:\n - type: git\n   repo: git@github.com:yourname/yourname.github.io.git\n     branch: branch\n  message: message\n```\n## 5.常用命令\n\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\nhexo clean  删除public文件夹\n\n```\n## 6.常见问题\n```\n发布不上去：\nnpm install hexo-deployer-git --save 安装依赖包\n```\n## 7.具体设置\nhexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的；\n- 修改主题\n\n修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。\n如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。\n\n全局的_config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。\n需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。\n\n本文参考了博客：[参考博客](https://geeksblog.cc/hexo-githup-blog.html)","tags":["hexo"],"categories":["others"]},{"title":"线程和并发--基础操作","url":"/2018/09/17/线程和并发--基础操作/","content":"## 概述\n**并发和并行**是即相似又有区别：\n- 并行：指两个或多个事件在同一时刻发生；\n- 并发：指两个或多个事件在同一时间段内发生。\n<!--more-->\n**进程**是指一个内存中运行中的应用程序。每个进程都有自己独立的一块内存空间，一个应用程序可以同时启动多个进程。比如在Windows系统中，一个运行的abc.exe就是一个进程。\n那么我们此时就可以处理同时玩游戏和听音乐的问题了，我们可以设计成两个程序，一个专门负责玩游戏，一个专门负责听音乐。\n但是问题来了，要是要设计一个植物大战僵尸游戏，我得开N个进程才能完成多个功能，这样的设计显然是不合理的。\n更何况大多数操作系统都不需要一个进程访问其他进程的内存空间，也就是说进程之间的通信很不方便。\n此时我们得引入“线程”这门技术，来解决这个问题。\n\n**线程**是指进程中的一个执行任务(控制单元)，一个进程可以同时并发运行多个线程，如：多线程下载软件。\n一个进程至少有一个线程，为了提高效率，可以在一个进程中开启多个执行任务,即多线程。\n多进程：操作系统中同时运行的多个程序。\n多线程：在同一个进程中同时运行的多个任务。\n我们查看Windows环境下的任务管理器：\n  在操作系统中允许多个任务，每一个任务就是一个进程，每一个进程也可以同时执行多个任务，每一个任务就是线程。\n\n**多线程**作为一种多任务、并发的工作方式，当然有其存在优势：\n\n- 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。\n- 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.\n- Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程.\n\n## 用java语言创建进程\n\n```\nimport java.io.IOException;\n//如何用java语言开启一个进程\npublic class ProcessDemo {\n\tpublic static void main(String[] args) throws IOException{\n\t\t//方式一：使用Runtime的exec方法\n\t\tRuntime.getRuntime().exec(\"notepad\");\n\t\t//方式二：使用ProcessBuilder类中的start方法\n\t\tProcessBuilder pb = new ProcessBuilder(\"notepad\");\n\t\tpb.start();\n\t}\n}\n\n```\n## 创建和启动线程\n\n### 方式一：继承Thread类\n\n1. 自定义类继承于Thread类，那么该自定义类就是线程类；\n\n2．覆写run方法，将线程运行的代码存放在run中；\n\n3．创建自定义类的对象，即线程对象；\n\n4．调用线程对象的start方法，启动线程。\n\n```\npackage thread_create;\n//继承方式 创建和启动线程\nclass MusicThread extends Thread{      //MusicThread是线程子类\n\tpublic void run() {               //子类必须重写run()方法\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"听音乐\"+i);\n\t\t}\n\t}\n\t\n}\npublic class ExtendsThreadDemo {\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"玩游戏\"+i);\n\t\t\tif( i == 10){\n\t\t\t\tMusicThread t = new MusicThread();  //创建线程子类的实例\n\t\t\t\tt.start(); //底层也调用了run();  启动线程\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}\n\n```\n\n### 方式二：实现Runnable接口\n\n1．自定义类实现Runnable接口；\n\n2．覆写run方法，线程运行的代码存放在run中；\n\n3．通过Thread类创建线程对象，并将实现了Runnable接口的实现类对象作为参数传递给Thread类的构造器。\n\n4．Thread类对象调用start方法，启动线程。\n```\nclass MusicRunnable implements java.lang.Runnable{         //注意MusicRunnable类不是线程类或者线程子类\n\tpublic void run() {\t\t\t\t\t\t\t\t\t   //接口的实现必须覆盖方法。\t\t\t\t\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"听音乐\"+i);\n\t\t}\n\t}\n}\npublic class ImplementsRunnableDemo {\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0 ;i < 50;i++)\n\t\t{\n\t\t\tSystem.out.println(\"玩游戏\"+i);\n\t\t\tif( i == 10){\n\t\t\t\tRunnable t = new MusicRunnable();        //启动线程必须用线程类对象调用start();\n\t\t\t\tnew Thread(t).start();             //类Thread的一个构造器中Thread(Runnable target)分配新的 Thread 对象。\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n### 对比两种方法（吃苹果比赛）\n**1、继承Thread类** \n\n```\n/**\n * \t案例:存在50个苹果,现在有请三个童鞋(小A,小B,小C)上台表演吃苹果.\n * \t\t因为A,B,C三个人可以同时吃苹果,此时得使用多线程技术来实现这个案例.\n *\n *       此处程序不合理,ABC每个线程都执行50次,即ABC每个人都吃一次编号50的苹果\n */\nclass Person extends Thread{\n\tprivate  int num= 50;\n\tPerson(String name){\n\t\tsuper(name);\n\t}\n\tpublic void run() {\n\t\tfor(int i = 0;i < 50;i++){\n\t\tif(num > 0)\t\n\t\tSystem.out.println(super.getName()+\"吃了第\"+num--+\"个苹果\");\n\t\t}\n\t}\t\n}\n//使用继承Thread的方式创建线程\npublic class ExtendsDemo {\n\tpublic static void main(String[] args){\n\t\tPerson p1 = new Person(\"A\");\n\t\tp1.start();\n\t\tPerson p2 = new Person(\"B\");\n\t\tp2.start();\n\t\tPerson p3 = new Person(\"C\");\n\t\tp3.start();\n\t}\n}\n\n```\n\n**2、实现Runnable接口** \n\n```\nclass Apple implements Runnable{\n\tprivate int num = 50;\n\tpublic void run(){\n\t\tfor(int i = 0; i< 50 ;i++){\n\t\t\tif(num > 0){\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\"吃了第\"+num--+\"个苹果\");\n\t\t\t}//Thread.currentThread()   返回对当前正在执行的线程对象的引用。\n\t\t}\n\t}\n}\n//使用实现Runnable接口的方式，这种方法可以解决此问题\npublic class ImplementsDemo {\n\tpublic static void main(String[] args){\n\t\tRunnable r = new Apple();\n\t\tnew Thread(r,\"A\").start();\n\t\tnew Thread(r,\"B\").start();\n\t\tnew Thread(r,\"C\").start();\n\t}\n}\n\n```\n\n**对比**\n\n继承方式：\n- java中类是单继承的，如果继承了Thread，该类就不能再有其他的直接父类\n- 从操作上分析，继承方式更简单，获取线程的名字也简单（操作上，简单）\n- 从多线程共享一个资源上分析，**继承方式不能做到**\n\n实现方式\n- java中类可以实现接口，此时该类还可以继承其他类，并且可以实现接口（设计上，更优雅）\n- 从操作上分析，实现方式稍微复杂点，获取线程的名字比较复杂，得使用currentThread()获取当前线程的引用。\n- 从多线程共享一个资源上分析，**实现方式可以做到**。\n\n\n\n"}]